# -*- coding: utf-8 -*-
"""Reverse_first_threat_attack_type_gdelt.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/
"""

#### PROVIAMO AL CONTRARIO cIOE DALLE NEWS, CLASSIFICHIAMO SE SONO ATTACCHI O THREATS (HYBRID, CYBER O KINETIC), IN QUALE SEGMENT E POI FACCIAMO MITRE ECC

!pip install openai
import pandas as pd
from openai import OpenAI
import re
import time

# Your API token and base URL
client = OpenAI(
    api_key='your api',
    base_url="https://api-gpt.jrc.ec.europa.eu/v1"
)


# Load the dataset (make sure the dataset path is correct)
df = pd.read_csv('/content/c.150_newspaper_with_attack_type.csv')  # Replace with actual file path

# Define the prompt for teaching the model about the threats for each segment
def teach_threat_definitions():
    prompt = """
    You are an expert in satellite communications, satellite operations, and space-related threats. Please read the following news article summary and perform the following tasks, considering the context and possible synonyms:

    **1. Identify if the news is about a threat or an attack**.
       - **Attack**: An intentional, direct, and aggressive act aimed at damaging or destroying a satellite or satellite infrastructure.
       - **Threat**: A potential or implied danger or risk, not necessarily an active or immediate attack, but one that could lead to harm.

    **2. Classify the type of threat (if applicable)**:
       - **Kinetic**: Physical attacks such as antisatellite (ASAT) weapons, directed-energy weapons (e.g., lasers, RF weapons), or any physical means aimed at destroying or disabling satellites.
       - **Cyber**: Digital attacks, hacking, or cyber intrusion aimed at disrupting or gaining unauthorized control over satellite systems or data.
       - **Electromagnetic**: Attacks that use electromagnetic techniques, such as jamming or spoofing signals, to disable satellite communication or disrupt operations.
       - **Hybrid**: A blend of multiple threats (e.g., cyber-attacks combined with disinformation or jamming), often with the aim of confusing or incapacitating the satellite infrastructure in multiple ways.
       - **Hybrid Subtypes**: If hybrid, classify the specific types involved (e.g., "Hybrid - Cyber + Disinformation").

    **3. Identify the targeted segment(s)**:
       - **Space Segment**: The satellite and onboard technology (payload, bus).
       - **Ground Segment**: Ground stations, data centers, and any earth-based infrastructure involved in satellite operation.
       - **Uplink and Downlink Segment**: The communication channels between ground stations and satellites (including both uplink and downlink).
       - **User Segment**: Devices and applications relying on satellite data or services (e.g., satellite phones, GPS, TV).

    **Output format**:
    - Column 1: **Is it a threat or attack?** - Return either "Threat" or "Attack".
    - Column 2: **Type of threat** - Return one of: "Cyber", "Kinetic", "Electromagnetic", "Hybrid" (with subtypes if applicable), or "No relevant threat".
    - Column 3: **Targeted Segments** - List the relevant segments: "Space Segment", "Ground Segment", "Uplink and Downlink Segment", "User Segment", or "No relevant segment".

    Return the classification in the following format:

    - **Is it a threat or attack?**: [Threat/Attack]
    - **Type of threat**: [Cyber/Kinetic/Electromagnetic/Hybrid/Subtype]
    - **Targeted Segments**: [Space Segment, Ground Segment, Uplink and Downlink Segment, User Segment]
    - **Reasoning**: [A brief explanation in 50 words or less.]

    Text: {text}
    """
    return prompt

# Function to analyze and classify threats for each news article summary
def classify_threats(row):
    try:
        text = row['text']  # Using 'text' column for threat classification

        # Create the prompt for classification
        prompt = teach_threat_definitions()

        # Send the request to OpenAI's API for classification (assuming `client` is configured)
        chat_completion = client.chat.completions.create(
            model="llama-3.3-70b-instruct",  # Using the desired model
            messages=[{"role": "system", "content": "You are an expert in satellite operations and communication."},
                      {"role": "user", "content": f"{prompt}\nText: {text}"}],
            stream=False,
            temperature=0.7,
            timeout=100  # Increased timeout to 100 seconds
        )

        # Extract the response (raw response text)
        raw_response = chat_completion.choices[0].message.content.strip()

        # Debugging: Print the raw response to understand how it's formatted
        print(f"Raw response for text: {text}\n{raw_response}\n")

        # Extract classification fields using regex
        is_attack_or_threat = re.search(r"Is it a threat or attack\?\s*:\s*(\w+)", raw_response)
        threat_type = re.search(r"Type of threat\s*:\s*(\w+)", raw_response)
        targeted_segments = re.search(r"Targeted Segments\s*:\s*(.*)", raw_response)
        reasoning = re.search(r"Reasoning\s*:\s*(.*)", raw_response)

        # Return the raw response along with the classification data and reasoning
        return [
            raw_response,  # Save the full raw response
            is_attack_or_threat.group(1) if is_attack_or_threat else "Error",  # Threat or Attack
            threat_type.group(1) if threat_type else "Error",  # Threat Type
            targeted_segments.group(1) if targeted_segments else "Error",  # Targeted Segments
            reasoning.group(1) if reasoning else "Error"  # Reasoning
        ]

    except Exception as e:
        print(f"Error analyzing text: {e}")
        return ["Error", "Error", "Error", "Error", "Error"]  # Return error in case of issues

# Apply the function to the DataFrame to classify each row based on the 'text' column
df[['raw_response', 'is_threat_or_attack', 'type_of_threat', 'targeted_segments', 'reasoning']] = df.apply(classify_threats, axis=1, result_type='expand')

# Save the results to a new CSV file with the raw responses, classifications, and reasoning
df.to_csv('/content/4_gdelt_reverse.csv', index=False)

print("The file has been saved successfully as '4_gdelt_marco_reverse.csv'.")

df.head()

import pandas as pd
import re

# Load the existing CSV file
df = pd.read_csv('/content/4_gdelt_reverse.csv')

# Function to extract each part from the raw_response
def split_raw_response(raw_response):
    # Initialize empty fields
    threat_attack = None
    threat_type = None
    targeted_segments = None
    reasoning = None

    # Extract the relevant parts using regex
    threat_attack_match = re.search(r"\*\*Is it a threat or attack\?\*\*: ([^\n]+)", raw_response)
    if threat_attack_match:
        threat_attack = threat_attack_match.group(1)

    threat_type_match = re.search(r"\*\*Type of threat\*\*: ([^\n]+)", raw_response)
    if threat_type_match:
        threat_type = threat_type_match.group(1)

    targeted_segments_match = re.search(r"\*\*Targeted Segments\*\*: ([^\n]+)", raw_response)
    if targeted_segments_match:
        targeted_segments = targeted_segments_match.group(1)

    reasoning_match = re.search(r"\*\*Reasoning\*\*: ([^\n]+)", raw_response)
    if reasoning_match:
        reasoning = reasoning_match.group(1)

    return pd.Series([threat_attack, threat_type, targeted_segments, reasoning])

# Apply the function to the raw_response column and create new columns
df[['threat_attack', 'threat_type', 'targeted_segments', 'reasoning']] = df['raw_response'].apply(split_raw_response)

# Check the final DataFrame to verify everything looks good
print(df[['raw_response', 'threat_attack', 'threat_type', 'targeted_segments', 'reasoning']].head())

# Save the updated DataFrame to a new CSV file
df.to_csv('/content/5_gdelt_marco_reverse_split.csv', index=False)













