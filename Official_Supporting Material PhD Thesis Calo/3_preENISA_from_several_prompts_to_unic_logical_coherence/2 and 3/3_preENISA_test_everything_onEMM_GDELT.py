# -*- coding: utf-8 -*-
"""test_everything_onEMM_GDELT.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1aThf9ZPB6w2LyKY4vVWJMOMY_TB3lhFm
"""

!pip install openai langdetect  # Install langdetect for language detection

import pandas as pd
from openai import OpenAI
import re
import time
from langdetect import detect  # Language detection library

# Your API token and base URL
client = OpenAI(
    api_key='AGPk',
    base_url="https://api-gpt.jrc.ec.europa.eu/v1"
)

# Load the dataset (make sure the dataset path is correct)
df = pd.read_csv('/content/test_total_gdelt.csv')  # Replace with actual file path

# Define the prompt for teaching the model about the threats for each segment
def teach_threat_definitions():
    prompt = """
    You are an expert in satellite communications, satellite operations, and space-related threats. You also know the actors' nationalities. Please read the following news article summary and perform the following tasks:

    **1. Extract information about the Attacker and Target involved in the event**:
       - **Attacker Name**: The name of the attacker (the party initiating the action).
       - **Attacker Country**: The country of the attacker.
       - **Target Name**: The name of the target (the party being attacked).
       - **Target Country**: The country of the target.

    **2. Classify the text**:
       - **Attack**: An intentional, direct, and aggressive act aimed at damaging or destroying a satellite or satellite infrastructure.
       - **Threat**: A potential or implied danger or risk, not necessarily an active or immediate attack, but one that could lead to harm.
       - **Incident**: A natural event, chance occurrence, or unclear intent, whether accidental or not.
       - **None of them**: The text doesn't fit into any of the above categories.

    **3. Classify the type of threat, attack, or incident (if applicable)**:
       - **Kinetic**: Physical attacks such as antisatellite (ASAT) weapons, directed-energy weapons (e.g., lasers, RF weapons), or any physical means aimed at destroying or disabling satellites.
       - **Cyber**: Digital attacks, hacking, or cyber intrusion aimed at disrupting or gaining unauthorized control over satellite systems or data.
       - **Electromagnetic**: Attacks that use electromagnetic techniques, such as jamming or spoofing signals, to disable satellite communication or disrupt operations.
       - **Hybrid**: A blend of multiple threats introduced by the JRC-NATO Hybrid threats CORE-model (e.g., cyber-attacks combined with disinformation or jamming), often with the aim of confusing or incapacitating the satellite infrastructure in multiple ways.
       - **Hybrid Subtypes**: If hybrid, classify the specific types involved (e.g., "Hybrid - Cyber + Disinformation").

    **4. Identify the targeted segment(s)**:
       - **Space Segment**: The satellite and onboard technology (payload, bus).
       - **Ground Segment**: Ground stations, data centers, and any earth-based infrastructure involved in satellite operation.
       - **Uplink and Downlink Segment**: The communication channels between ground stations and satellites (including both uplink and downlink).
       - **User Segment**: Devices and applications relying on satellite data or services (e.g., satellite phones, GPS, TV).

    **5. Identify the space-related sub-type of the attack/threat/incident with this vocabulary**:
       - **Cyber Threats**: Malware Attacks, Phishing, Data Manipulation, DoS, Hacking, Supply Chain Attacks
       - **Kinetic Threats**: Anti-Satellite (ASAT) Weapons, Kinetic Energy Weapons (KEWs), Space Debris Impact, Orbital Maneuver Attacks
       - **Electromagnetic Threats**: Jamming, Spoofing, EMP, RFI, Directed Energy Weapons
       - **Natural Threats**: Space Weather Events, Cosmic Radiation, Micrometeoroids and Space Dust

    **6. Space-related Vulnerabilities and Capabilities**:
       - **Vulnerabilities**: Vulnerabilities related to satellite infrastructure or communication systems.
       - **Capabilities**: Capabilities related to satellite communication networks or technological advancements.

    **7. Language Analysis**:
       - Tone: Formal, neutral, aggressive, sensational, or emotionally charged.
       - Polarization: Is the text polarized (Objective/Polarized/Fictional)? If yes, mention which side is polarized.
       - Credibility: Is id the text fictional, for example using past verbs for future years?

    **Output format**:
    - **Is it a threat or attack?**: [Threat/Attack]
    - **Type of threat**: [Cyber/Kinetic/Electromagnetic/Hybrid/Subtype]
    - **Targeted Segments**: [Space Segment, Ground Segment, Uplink and Downlink Segment, User Segment]
    - **Spatial Sub-Type of Threat**: [ASAT Weapons, Unauthorized Access, etc. Use only the vocabulary from the prompt]
    - **Is there any space-related vulnerability?**: [Yes/No, and details if yes]
    - **Is there any space-related capability?**: [Yes/No, and details if yes]
    - **How is the language?**: [Neutral/Formal]
    - **Is it Polarized or Fictional?**: [No/Yes]
    - **Is it Fictional?**: [No/Yes]
    - **Reasoning**: [A brief explanation in 50 words or less.]
    Text: {text}
    """
    return prompt

# Function to analyze and classify threats for each news article summary
def classify_threats(row):
    try:
        text = row['text']  # Using 'text' column for threat classification

        # Detect language using langdetect library
        detected_language = detect(text)

        # Create the prompt for classification
        prompt = teach_threat_definitions()

        # Send the request to OpenAI's API for classification (assuming `client` is configured)
        chat_completion = client.chat.completions.create(
            model="llama-3.3-70b-instruct",  # Using the desired model
            messages=[{"role": "system", "content": "You are an expert in satellite operations and communication."},
                      {"role": "user", "content": f"{prompt}\nText: {text}"}],
            stream=False,
            temperature=0.3,
            timeout=20  # Increased timeout to 100 seconds
        )

        # Extract the response (raw response text)
        raw_response = chat_completion.choices[0].message.content.strip()

        # Append the detected language to the raw response
        final_response = f"Detected Language: {detected_language}\n{raw_response}"

        # Debugging: Print the raw response to understand how it's formatted
        print(f"Raw response for text: {text}\n{final_response}\n")

        # Return the full raw response for the questions
        return [final_response]  # Return the entire structured output as a single string

    except Exception as e:
        print(f"Error analyzing text: {e}")
        return ["Error"]  # Return error in case of issues

# Apply the function to the DataFrame to classify each row based on the 'text' column
df['raw_resp'] = df.apply(classify_threats, axis=1)
from google.colab import files

df.to_csv('provanuova_gdelt_classification.csv', index=False) # Save DataFrame to CSV
files.download('provanuova_gdelt_classification.csv') # Download the CSV file

df.head()



df.head()

import pandas as pd

# Open and read the CSV file
df = pd.read_csv('/content/test_complete_emm_classification (1).csv')

# Define the patterns to remove
patterns = [
    "Here is the analysis of the text\n",
    "Here is the Analysis of the given text\n",
    "Here is the output in the requested format:\n",
    "Here's the Analysis of the given text\n",
    "Here\'s th analysis based on the provided text:\n",
    "Here's the Analysis of the provided text\n",
    "Here is the output format with the requested format:\n"
]

# Function to remove patterns from a string
def remove_patterns(text):
    for pattern in patterns:
        text = text.replace(pattern, "")  # Replace pattern with empty string
    return text

# Apply the function to the 'raw_resp' column
df['raw_resp'] = df['raw_resp'].apply(remove_patterns)

# Save the modified DataFrame (optional)
df.to_csv('cleaned_gdelt_classification.csv', index=False)

df.head()

# Assuming 'df' is your DataFrame from the previous step

# Split the 'raw_resp' column by newline and create new columns
# expand=True creates a new DataFrame from the split strings
split_df = df['raw_resp'].str.split('\n', expand=True)

# Get the column names based on the first row (assuming it has all the headers)
column_names = split_df.iloc[0].tolist()

# Set the column names for the split DataFrame
split_df.columns = column_names

# Drop the first row (which was used for column names)
split_df = split_df.drop(0, axis=0)

# Reset the index to avoid issues
split_df = split_df.reset_index(drop=True)


# Concatenate the split DataFrame with the original DataFrame
df = pd.concat([df, split_df], axis=1)

# Drop the original 'raw_resp' column
df = df.drop('raw_resp', axis=1)

# Save the updated DataFrame (optional)
df.to_csv('split_gdelt_classification.csv', index=False)

df.head()

import pandas as pd
import re

# Open and read the CSV file
df = pd.read_csv('/content/test_complete_emm_classification (1).csv')

# Function to extract text between two delimiters
def extract_between_delimiters(text, start_delimiter, end_delimiter):
    try:
        # Find the starting and ending positions of the delimiters
        start_pos = text.index(start_delimiter) + len(start_delimiter)
        end_pos = text.index(end_delimiter, start_pos)
        # Extract the text between the delimiters
        extracted_text = text[start_pos:end_pos].strip()
        return extracted_text
    except ValueError:
        # Return None if either delimiter is not found
        return None

# Define the delimiters for each column
delimiters = {
    "language_written": ("Detected Language:", "**Is it a threat or attack?"),
    "threat_attack": ("**Is it a threat or attack?", "**Type of threat"),
    "threat_type": ("**Type of threat","**Targeted Segments"),
    "Targeted_segment": ("**Targeted Segments","**Sub-Type of Threat"),
    "threat_sub_type": ("**Sub-Type of Threat","**Is there any space-related vulnerability?"),
    "Vulnerability": ("**Is there any space-related vulnerability?","**Is there any space-related capability?"),
    "Capability": ("**Is there any space-related capability?", "**How is the language?"),
    "Language-tone": ("**How is the language?","**Is it Polarized or Fictional?"),
    "Polarization": ("**Is it Polarized or Fictional?","**Is it Fictional?"),
    "Fictional": ("**Is it Fictional?:","**Reasoning:"),
    "Reasoning_all": ("**Reasoning","**Attacker name"), # Corrected delimiters for "Reasoning_all"
    "Attacker_name": ("**Attacker name", "**Attacker country"), # Corrected delimiters for "Attacker_name"
    "Attacker_country": ("**Attacker country", "**Target name"), # Corrected delimiters for "Attacker_country"
    "Target_name": ("**Target name", "**Target country"), # Corrected delimiters for "Target_name"
    "Target_country": ("**Target country", "")  # Corrected delimiters for "Target_country" by adding an empty end_delimiter
}

# Create new columns by applying the extraction function
for column_name, (start_delimiter, end_delimiter) in delimiters.items():
    df[column_name] = df['raw_resp'].apply(lambda text: extract_between_delimiters(text, start_delimiter, end_delimiter))

# Display the updated DataFrame (optional)
df.head()









