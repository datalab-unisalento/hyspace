# -*- coding: utf-8 -*-
"""threat_sub_type addition.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/
"""

import pandas as pd
from openai import OpenAI
import re
import time

# Your API token and base URL
client = OpenAI(
    api_key='your api,
    base_url="https://api-gpt.jrc.ec.europa.eu/v1"
)

# Load the dataset (make sure the dataset path is correct)
df = pd.read_csv('/content/5_gdelt_reverse_attribut.csv')  # Replace with actual file path

# Define the prompt for teaching the model about the threat sub-types for each segment
def teach_threat_sub_type():
    prompt = """
    You are an expert in space technology, satellite operations, and threat analysis. Please read the following text and perform the following task:

    **Task**: Identify the sub-type of the attack/threat/incident based on the provided information. The classification should be aligned with the threat_type, which can be one of the following categories: Cyber, Kinetic, Electromagnetic, or Natural.

    Please select one of the sub-types listed below based on the threat_type:

    **Cyber Threats**:
        - Malware Attacks (e.g., virus, trojan, ransomware, spyware)
        - Phishing Attacks (e.g., spear phishing, credential harvesting)
        - Data Manipulation (e.g., data injection, data spoofing)
        - Denial of Service (DoS) (e.g., jamming, flooding)
        - Hacking and Unauthorized Access (e.g., zero-day exploits, backdoor entry, privilege escalation)
        - Supply Chain Attacks (e.g., hardware manipulation, software compromise)

    **Kinetic Threats**:
        - Anti-Satellite (ASAT) Weapons (e.g., direct-ascent ASAT, co-orbital ASAT)
        - Kinetic Energy Weapons (KEWs) (e.g., laser blinding, kinetic impact)
        - Space Debris Impact (e.g., micrometeoroid impacts, collision with orbital debris)
        - Orbital Maneuver Attacks (e.g., unwanted orbital changes)

    **Electromagnetic Threats**:
        - Jamming (e.g., signal jamming, broadband jamming, spot jamming)
        - Spoofing (e.g., GPS spoofing, signal spoofing)
        - Electromagnetic Pulse (EMP) (e.g., nuclear EMP, non-nuclear EMP)
        - Radio Frequency Interference (RFI) (e.g., interference from unauthorized transmissions, harmonic distortion)
        - Directed Energy Weapons (DEW) (e.g., laser directed energy attacks, microwave weapons)

    **Natural Threats**:
        - Space Weather Events (e.g., solar flares, coronal mass ejections, geomagnetic storms)
        - Cosmic Radiation (e.g., cosmic rays, galactic cosmic radiation)
        - Micrometeoroids and Space Dust (e.g., micrometeoroid impacts, dust cloud encounters)

    **Output format**:
    - **Sub-type**: [Sub-type]
    - **Reasoning**: [Brief explanation]

    Text: {text}
    """
    return prompt

# Function to classify threats and attacks in space infrastructure
# Function to analyze and classify threats for each news article summary
def classify_threats(row):
    try:
        text = row['text']  # Using 'text' column for threat classification

        # Create the prompt for classification
        prompt = teach_threat_sub_type()

        # Send the request to OpenAI's API for classification (assuming `client` is configured)
        chat_completion = client.chat.completions.create(
            model="llama-3.3-70b-instruct",  # Using the desired model
            messages=[{"role": "system", "content": "You are an expert in satellite operations and communication."},
                      {"role": "user", "content": f"{prompt}\nText: {text}"}],
            stream=False,
            temperature=0.4,
            timeout=10  # Increased timeout to 10 seconds
        )

        # Extract the response (raw response text)
        raw_response = chat_completion.choices[0].message.content.strip()

        # Debugging: Print the raw response to understand how it's formatted
        print(f"Raw response for text: {text}\n{raw_response}\n")

        # Extract classification fields using regex
        is_attack_or_threat = re.search(r"Is it a threat or attack\?\s*:\s*(\w+)", raw_response)
        threat_type = re.search(r"Type of threat\s*:\s*(\w+)", raw_response)
        targeted_segments = re.search(r"Targeted Segments\s*:\s*(.*)", raw_response)
        reasoning = re.search(r"Reasoning\s*:\s*(.*)", raw_response)
        sub_type = re.search(r"Sub-type\s*:\s*(\w+)", raw_response)

        # If sub-type is missing, set it to 'unknown'
        if not sub_type:
            sub_type_value = 'unknown'
            sub_type_reasoning = "The information is insufficient to classify the sub-type."
        else:
            sub_type_value = sub_type.group(1)
            sub_type_reasoning = reasoning.group(1) if reasoning else "Error in reasoning."

        # Return the raw response along with the classification data and reasoning
        return [
            raw_response,  # Save the full raw response
            is_attack_or_threat.group(1) if is_attack_or_threat else "Error",  # Threat or Attack
            threat_type.group(1) if threat_type else "Error",  # Threat Type
            targeted_segments.group(1) if targeted_segments else "Error",  # Targeted Segments
            sub_type_value,  # Sub-type (or 'unknown' if not determined)
            sub_type_reasoning  # Reasoning for sub-type (or default reasoning if unknown)
        ]

    except Exception as e:
        print(f"Error analyzing text: {e}")
        return ["Error", "Error", "Error", "Error", "Error", "Error"]  # Return error in case of issues

# Apply the function to the DataFrame to classify each row based on the 'text' column
df[['raw_response2', 'is_threat_or_attack2', 'type_of_threat2', 'targeted_segments2', 'sub_type', 'sub_type_reasoning']] = df.apply(classify_threats, axis=1, result_type='expand')

# Save the results to a new CSV file with the raw responses, classifications, and reasoning
df.to_csv('/content/gdelt_plus.csv', index=False)

print("The file has been saved successfully as 'gdelt_plus.csv'.")

print(df.head())

import re

def extract_sub_type(text):
    match = re.search(r"Sub-type\s*:\s*(.*?)\nReasoning", text, re.IGNORECASE)
    if match:
        return match.group(1).strip()
    else:
        return None  # Or any other default value like "Not Found"

df['sub_type'] = df['raw_response2'].apply(extract_sub_type)
def extract_reasoning(text):
    match = re.search(r"Reasoning\s*:\s*(.*)", text, re.IGNORECASE)
    if match:
        return match.group(1).strip()
    else:
        return None  # Or any other default value like "Not Found"

df['why'] = df['raw_response2'].apply(extract_reasoning)
df.to_csv('gdelt_plus_updated.csv', index=False)

df.head()

import pandas as pd
from openai import OpenAI
import re
import time

# Your API token and base URL
client = OpenAI(
    api_key='your api',
    base_url="https://api-gpt.jrc.ec.europa.eu/v1"
)

# Load the dataset (make sure the dataset path is correct)
df = pd.read_excel('/content/_attributi.xlsx')  # Replace with actual file path

# Define the prompt for teaching the model about the threat sub-types for each segment
def teach_threat_sub_type():
    prompt = """
    You are an expert in space technology, satellite operations, and threat analysis. Please read the following text and perform the following task:

    **Task**: Identify the sub-type of the attack/threat/incident based on the provided information. The classification should be aligned with the threat_type, which can be one of the following categories: Cyber, Kinetic, Electromagnetic, or Natural.

    Please select one of the sub-types listed below based on the threat_type:

    **Cyber Threats**:
        - Malware Attacks (e.g., virus, trojan, ransomware, spyware)
        - Phishing Attacks (e.g., spear phishing, credential harvesting)
        - Data Manipulation (e.g., data injection, data spoofing)
        - Denial of Service (DoS) (e.g., jamming, flooding)
        - Hacking and Unauthorized Access (e.g., zero-day exploits, backdoor entry, privilege escalation)
        - Supply Chain Attacks (e.g., hardware manipulation, software compromise)

    **Kinetic Threats**:
        - Anti-Satellite (ASAT) Weapons (e.g., direct-ascent ASAT, co-orbital ASAT)
        - Kinetic Energy Weapons (KEWs) (e.g., laser blinding, kinetic impact)
        - Space Debris Impact (e.g., micrometeoroid impacts, collision with orbital debris)
        - Orbital Maneuver Attacks (e.g., unwanted orbital changes)

    **Electromagnetic Threats**:
        - Jamming (e.g., signal jamming, broadband jamming, spot jamming)
        - Spoofing (e.g., GPS spoofing, signal spoofing)
        - Electromagnetic Pulse (EMP) (e.g., nuclear EMP, non-nuclear EMP)
        - Radio Frequency Interference (RFI) (e.g., interference from unauthorized transmissions, harmonic distortion)
        - Directed Energy Weapons (DEW) (e.g., laser directed energy attacks, microwave weapons)

    **Natural Threats**:
        - Space Weather Events (e.g., solar flares, coronal mass ejections, geomagnetic storms)
        - Cosmic Radiation (e.g., cosmic rays, galactic cosmic radiation)
        - Micrometeoroids and Space Dust (e.g., micrometeoroid impacts, dust cloud encounters)

    **Output format**:
    - **Sub-type**: [Sub-type]
    - **Reasoning**: [Brief explanation]

    Text: {text}
    """
    return prompt

# Function to classify threats and attacks in space infrastructure
# Function to analyze and classify threats for each news article summary
def classify_threats(row):
    try:
        text = row['text']  # Using 'text' column for threat classification

        # Create the prompt for classification
        prompt = teach_threat_sub_type()

        # Send the request to OpenAI's API for classification (assuming `client` is configured)
        chat_completion = client.chat.completions.create(
            model="llama-3.3-70b-instruct",  # Using the desired model
            messages=[{"role": "system", "content": "You are an expert in satellite operations and communication."},
                      {"role": "user", "content": f"{prompt}\nText: {text}"}],
            stream=False,
            temperature=0.4,
            timeout=10  # Increased timeout to 10 seconds
        )

        # Extract the response (raw response text)
        raw_response = chat_completion.choices[0].message.content.strip()

        # Debugging: Print the raw response to understand how it's formatted
        print(f"Raw response for text: {text}\n{raw_response}\n")

        # Extract classification fields using regex
        is_attack_or_threat = re.search(r"Is it a threat or attack\?\s*:\s*(\w+)", raw_response)
        threat_type = re.search(r"Type of threat\s*:\s*(\w+)", raw_response)
        targeted_segments = re.search(r"Targeted Segments\s*:\s*(.*)", raw_response)
        reasoning = re.search(r"Reasoning\s*:\s*(.*)", raw_response)
        sub_type = re.search(r"Sub-type\s*:\s*(\w+)", raw_response)

        # If sub-type is missing, set it to 'unknown'
        if not sub_type:
            sub_type_value = 'unknown'
            sub_type_reasoning = "The information is insufficient to classify the sub-type."
        else:
            sub_type_value = sub_type.group(1)
            sub_type_reasoning = reasoning.group(1) if reasoning else "Error in reasoning."

        # Return the raw response along with the classification data and reasoning
        return [
            raw_response,  # Save the full raw response
            is_attack_or_threat.group(1) if is_attack_or_threat else "Error",  # Threat or Attack
            threat_type.group(1) if threat_type else "Error",  # Threat Type
            targeted_segments.group(1) if targeted_segments else "Error",  # Targeted Segments
            sub_type_value,  # Sub-type (or 'unknown' if not determined)
            sub_type_reasoning  # Reasoning for sub-type (or default reasoning if unknown)
        ]

    except Exception as e:
        print(f"Error analyzing text: {e}")
        return ["Error", "Error", "Error", "Error", "Error", "Error"]  # Return error in case of issues

# Apply the function to the DataFrame to classify each row based on the 'text' column
df[['raw_response3', 'is_threat_or_attack2', 'type_of_threat2', 'targeted_segments2', 'sub_type', 'sub_type_reasoning']] = df.apply(classify_threats, axis=1, result_type='expand')

# Save the results to a new CSV file with the raw responses, classifications, and reasoning
df.to_csv('/content/EMM_plus.csv', index=False)

print("The file has been saved successfully as 'gdelt_plus.csv'.")

df.head()

import pandas as pd

# Read the CSV file into a pandas DataFrame
df = pd.read_csv('/content/gdelt_plus.csv')

# Display the first few rows of the DataFrame to verify
df.head()



# Delete the specified columns
df = df.drop(columns=['is_threat_or_attack2', 'type_of_threat2', 'targeted_segments2', 'sub_type', 'sub_type_reasoning'])

# Display the first few rows of the updated DataFrame to verify
df.head()

!pip install spacy
!python -m spacy download en_core_web_sm

import pandas as pd
import spacy

# Load the pre-trained spaCy model
nlp = spacy.load("en_core_web_sm")

threats = [
    # Cyber Threats
    "Malware Attacks",
    "Phishing Attacks",
    "Data Manipulation",
    "Denial of Service (DoS)",
    "Hacking and Unauthorized Access",
    "Supply Chain Attacks",

    # Kinetic Threats
    "Anti-Satellite (ASAT) Weapons",
    "Kinetic Energy Weapons (KEWs)",
    "Space Debris Impact",
    "Orbital Maneuver Attacks",
    "Ballistic Missiles",

    # Electromagnetic Threats
    "Jamming",
    "Spoofing",
    "Electromagnetic Pulse (EMP)",
    "Radio Frequency Interference (RFI)",
    "Directed Energy Weapons (DEW)",

    # Natural Threats
    "Space Weather Events",
    "Cosmic Radiation",
    "Micrometeoroids and Space Dust"
]


# Load your CSV file
df = pd.read_csv('/content/gdelt_plus.csv')  # Replace with your actual file path

# Function to classify threats based on text analysis
def classify_threats(text):
    # Process the text with spaCy
    doc = nlp(text)

    # A list to store the identified threats
    found_threats = []

    # Iterate through each word in the text to check for the threat names
    for threat in threats:
        if threat.lower() in text.lower():
            # Add the threat to the list
            found_threats.append(threat)

    # Now let's handle the context for "Denial of Service" and similar edge cases
    # For example, if "Denial of Service" is followed by "disruption", we should categorize it as "disruption"
    if "denial of service" in text.lower() and "disruption" in text.lower():
        found_threats = [term for term in found_threats if term != "Denial of Service (DoS)"]
        found_threats.append("disruption")

    # Return the identified threats as a comma-separated string
    return ", ".join(found_threats)

# Apply the function to classify threats in the text
df['classified_threats'] = df['raw_response2'].apply(classify_threats)

# Save the result to a new CSV file
df.to_csv('gdelt_plus_types.csv', index=False)

# Show the dataframe (optional)
print(df[['raw_response2', 'classified_threats']])

df.head()

# Delete the specified columns
df = df.drop(columns=['is_threat_or_attack2', 'type_of_threat2', 'targeted_segments2', 'sub_type', 'sub_type_reasoning'])

# Display the first few rows of the updated DataFrame to verify
df.head()

# Save the updated DataFrame to a new CSV file
df.to_csv('threats_plus.csv', index=False)

print("DataFrame saved to updated_emm_plus.csv")

df.head()

