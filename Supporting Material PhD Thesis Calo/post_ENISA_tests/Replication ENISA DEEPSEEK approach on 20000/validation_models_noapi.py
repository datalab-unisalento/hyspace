# -*- coding: utf-8 -*-
"""Validation models_noapi.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1zhEjBg1TrcHuzJQV-A1gnK2_Vx1WF9R9
"""

#DEEPSEEK V3 BaseLine

# INSTALL LIBRARIES
!pip install openai langdetect pandas openpyxl

import pandas as pd
import time
from openai import OpenAI
from langdetect import detect

# === CONFIG: THREE API CLIENTS ===
API_KEY_1 = "skf"
API_KEY_2 = "sk8"
API_KEY_3 = "sk-97"
BASE_URL = "https://openrouter.ai/api/v1"

client1 = OpenAI(api_key=API_KEY_1, base_url=BASE_URL)
client2 = OpenAI(api_key=API_KEY_2, base_url=BASE_URL)
client3 = OpenAI(api_key=API_KEY_3, base_url=BASE_URL)

# === LOAD DATA ===
df = pd.read_excel("/content/mancanti.xlsx")
df['description'] = df['description'].fillna('')

# === LOAD KNOWLEDGE BASE FILES ===
with open('/content/ground_kb.txt', 'r') as f:
    ground_kb = f.read()

with open('/content/space_kb.txt', 'r') as f:
    space_kb = f.read()

with open('/content/user_kb.txt', 'r') as f:
    user_kb = f.read()

with open('/content/hr_kb.txt', 'r') as f:
    hr_kb = f.read()

with open('/content/Space_Threat_Taxonomy.txt', 'r') as f:
    space_threat_taxonomy = f.read()

# === LOAD HYBRID THREATS FROM EXCEL ===
hybrid_df = pd.read_excel("/content/Hybrid Threats.xlsx")
hybrid_threats_text = "\n".join(hybrid_df['Hybrid Threats'].dropna().astype(str).tolist())

# Add Natural Threats
natural_threats = """
**Natural Threats**:
- Space Weather Events
- Cosmic Radiation
- Micrometeoroids and Space Dust
"""
full_threat_kb = space_threat_taxonomy + "\n" + natural_threats

# === LOAD THREAT TYPE MAPPING ===
threat_mapping_df = pd.read_excel("/content/ThreatType_Mapping.xlsx")

# === HELPER FUNCTION: QUERY MODEL WITH RETRY ===
def query_model(prompt, client, retries=1):
    for attempt in range(retries + 1):
        try:
            print(f"\nüöÄ Sending prompt (length={len(prompt)} chars)...")
            response = client.chat.completions.create(
                model="deepseek/deepseek-chat:free",
                messages=[{"role": "system", "content": "You are an expert in space cybersecurity and intelligence analysis."},
                          {"role": "user", "content": prompt}],
                stream=False,
                temperature=0.4
            )
            content = response.choices[0].message.content.strip()
            if not content:
                raise ValueError("Empty response from model.")
            return content
        except Exception as e:
            print(f"‚ö†Ô∏è Attempt {attempt + 1} failed: {e}")
            if attempt == retries:
                return f"<<ERROR: {str(e)}>>"
            time.sleep(3)

# === FUNCTION TO GET BEST MATCHING THREAT BASED ON COMMON TERMS INCLUDING INSTANCES ===
def get_best_matching_threat(description):
    matches = []
    for _, row in threat_mapping_df.iterrows():
        enisa_class = row['ENISA class']
        list_1_threat = row['List 1 Threat']
        relation = row['Relation']
        explanation = row['Explanation']
        instances = str(row.get('Instances', ''))

        keywords = [enisa_class, list_1_threat] + [i.strip() for i in instances.split(',') if i.strip()]
        if any(term.lower() in description.lower() for term in keywords):
            matches.append((enisa_class, list_1_threat, relation, explanation, instances))

    return matches if matches else None

# === MAIN PROCESSING LOOP ===
raw_responses = []
clients = [client1, client2, client3]

for idx in range(0, len(df)):
    row = df.iloc[idx]
    try:
        text = str(row['description'])
        lang = detect(text)
        matching_threats = get_best_matching_threat(text)

        if matching_threats:
            threat_str = "\n".join([
                f"ENISA Class: {enisa_class}, List 1 Threat: {list_1_threat}, Relation: {relation}, Explanation: {explanation}, Instances: {instances}"
                for enisa_class, list_1_threat, relation, explanation, instances in matching_threats
            ])
            prompt = f"""
You are an expert in space threats. The task is to classify the provided description of a space-related event or threat.
**IMPORTANT**: Only use vocabulary from the knowledge base for technical threats, and terminology from hybrid_df for non-technical ones.
**IMPORTANT**: If the news text is just about suppositions, or you cannot be sure, prefer mapping vulnerabilities and capabilities, instead of categories and classes.
Given the following knowledge base and event description, classify the event by matching it to relevant threats:

Knowledge Base:
{full_threat_kb}

Threat Mapping (Matching Threats):
{threat_str}

Event Description:
{text}

Classification:
"""
        else:
            prompt = f"""
You are an expert in space threats, technical (cyber-kinetic-electromagnetic) and non-technical hybrid threats (economic/legal/cognitive war, etc..). The task is to classify the provided description from news of a space-related events or threats to support the decision-making of defence agencies.
**IMPORTANT**: Only use vocabulary from the knowledge base for technical threats, and terminology from hybrid_df for non-technical ones.
**IMPORTANT**: If the description is just about general suppositions, or you cannot be sure, do not risk inferring and saying the false.
Given the following knowledge base and event description, classify the event by matching it to relevant threats:

Knowledge Base:
{full_threat_kb}

Event Description:
{text}

Classification:
"""

        # Append mitigation instructions
        prompt += f"""
**Key Points:**
- [Summarize key points from the news text that indicate threat relevance and classification]
- Please use only the taxonomy terminology:
- for non-technical threats {hybrid_threats_text}
- for technical threats {full_threat_kb}
- You can be supported in Threat Mapping (Matching Threats) {threat_str if matching_threats else 'N/A'}

**Confidence Evaluation Rules** (for assigning High / Medium / Low):
- **High**: The threat is explicitly confirmed or demonstrated in the text (e.g., direct statements of attacks, screenshots, or operational impact).
- **Medium**: The text implies or strongly suggests the threat but lacks direct confirmation or specific technical details.
- **Low**: The threat is speculative, hypothetical, denied by authoritative sources, or mentioned only as a possibility without supporting evidence.

Always pair confidence with specific **evidence** from the text (quote or paraphrased).

---

**Important notes to mitigate classification confusion when using taxonomy and instances:**

- The taxonomy classes and instances can overlap in terminology or granularity; ensure clear distinction between broad **classes** and specific **instances** when labeling.
- The relations **Direct**, **Indirect**, and **Mentioned** reflect levels of confidence and explicitness in the threat description; consider them carefully in the classification reasoning.
- When multiple instances appear within the same class, avoid ambiguous or overlapping labels by referencing the hierarchy and context.
- Be mindful that natural language in the news may use synonyms or varied terminology; align classifications strictly to the taxonomy vocabulary.
- If uncertainty remains high, prefer mapping to **vulnerabilities and capabilities** rather than forcing a direct class or instance label.
- Clearly separate **technical** and **non-technical (hybrid)** threat vocabularies.
- Always justify your classification with concrete **evidence** and **confidence levels** following the rules above.

---

Format output exactly like this (now including confidence and evidence for each threat class):
<<<RESPONSE_START>>>
1. Are there space-related issues? <Yes/No>
2. Is it a threat, attack, incident, or None? (Consider an incident something that happened by mistake; while an attack a voluntary violent action. A threat is something that can devolp in an attack or incident. But if the threat is too general, skip to vulnerabilties): <...>
3. Are the threats technical, or non-technical, or both?: <...>
4. For non-technical ones, which are the Hybrid Threat Types if present: <...>
5. for technical ones: All threats' **categories** from taxonomy that apply: <...>
6. Consequently for each of the previous, which **classes** **only** using vocabulary from **classes** in taxonomy: <...>
7. Term or technology in the analyzed text that retrieved the classed: <...>
8. Does the text provide enough information to retrieve threat **classes** classification? <Yes enough/Not enough>
9. Targeted Segments: <...>
10. Space-related vulnerability?: <Yes + explaination/No>
11. Space-related capability?: <Yes + explaination/No>
12. Lifecycle Phases Affected: <1, 2, 3, 4, 5, 6, 7,>
13. CIA Triad Affected: <C, I, A>
14. Detected Language: <...>
15. Language tone: <...>
16. Polarized?: <...>
17. Fictional?: <...>
18. Claim presence or illogic? <Claim, Illogic + explaination>
19. Reasoning for threat categories: <...>
20. Reasoning for threat classes: <...>
21. For each threat class, provide:
    - a. Confidence Level (High / Medium / Low) based on the strength of evidence in the text.
    - b. Textual evidence (quote or paraphrased) justifying the classification.
<<<RESPONSE_END>>>

Hybrid Threat Categories (from Hybrid Threats.xlsx):
{hybrid_threats_text}

Knowledge base:
{ground_kb}
{space_kb}
{user_kb}
{hr_kb}
{full_threat_kb}

News text to analyze:
{text}
"""

        print(f"üîç Prompt preview:\n{prompt[:500]}...\n{'-' * 60}")
        client = clients[idx % 3]
        content = query_model(prompt, client, retries=1)

        try:
            if "8." in content and "6." in content:
                q8_line = next(line for line in content.splitlines() if line.strip().startswith("8."))
                if "Not enough" in q8_line:
                    content_lines = content.splitlines()
                    for i, line in enumerate(content_lines):
                        if line.strip().startswith("6."):
                            content_lines[i] = "6. Consequently for each of the previous, which **classes** **only** using vocabulary from **classes** in taxonomy: <skip>"
                            break
                    content = "\n".join(content_lines)
        except Exception as e:
            print(f"‚ö†Ô∏è Post-processing failed: {e}")

        full_output = f"<<<RESPONSE_START>>>\nDetected Language: {lang}\n{content}\n<<<RESPONSE_END>>>"
        print(f"\n‚úÖ Row {idx + 1} done:\n{full_output}\n{'=' * 80}")
        raw_responses.append(full_output)
        time.sleep(10)

    except Exception as e:
        print(f"‚ùå Error at row {idx + 1}: {e}")
        raw_responses.append(f"<<<RESPONSE_START>>>\nError: {str(e)}\n<<<RESPONSE_END>>>")

# === SAVE OUTPUT ===
df['raw_resp'] = raw_responses
df.to_csv('space_emm_testConfidence2.csv', index=False)

# === DOWNLOAD (Colab only) ===
from google.colab import files
files.download('space_emm_testConfidence2.csv')

#The following cell is replicating  the deepseek approach on the whole gdelt year, because we have already compared and evaluated the approach on 4 models (next cells). After extracting title and texts from the whole 2022 gdelt year, 6726 news remain. Now we have to extract the features from them to know if there are threats, attacks, incidents and their subtypes.

# INSTALL LIBRARIES
!pip install openai langdetect pandas openpyxl

import pandas as pd
import time
from openai import OpenAI
from langdetect import detect

# === CONFIG: THREE API CLIENTS ===
API_KEY_1 = "97"
API_KEY_2 = "sk-"
API_KEY_3 = "skdc838"
API_KEY_4 = "s9"
API_KEY_5 = "skba2"
API_KEY_6 = "sk-o45a"
API_KEY_7 = "sk-orf9d11c"

BASE_URL = "https://openrouter.ai/api/v1"

client1 = OpenAI(api_key=API_KEY_1, base_url=BASE_URL)
client2 = OpenAI(api_key=API_KEY_2, base_url=BASE_URL)
client3 = OpenAI(api_key=API_KEY_3, base_url=BASE_URL)
client4 = OpenAI(api_key=API_KEY_4, base_url=BASE_URL)
client5 = OpenAI(api_key=API_KEY_5, base_url=BASE_URL)
client6 = OpenAI(api_key=API_KEY_6, base_url=BASE_URL)
client7 = OpenAI(api_key=API_KEY_7, base_url=BASE_URL)

# === LOAD DATA ===
df = pd.read_excel("/content/gdelt2022_noBlanks.xlsx")
df['description'] = df['description'].fillna('')

# === LOAD KNOWLEDGE BASE FILES ===
with open('/content/ground_kb.txt', 'r') as f:
    ground_kb = f.read()

with open('/content/space_kb.txt', 'r') as f:
    space_kb = f.read()

with open('/content/user_kb.txt', 'r') as f:
    user_kb = f.read()

with open('/content/hr_kb.txt', 'r') as f:
    hr_kb = f.read()

with open('/content/Space_Threat_Taxonomy.txt', 'r') as f:
    space_threat_taxonomy = f.read()

# === LOAD HYBRID THREATS FROM EXCEL ===
hybrid_df = pd.read_excel("/content/Hybrid Threats.xlsx")
hybrid_threats_text = "\n".join(hybrid_df['Hybrid Threats'].dropna().astype(str).tolist())

# Add Natural Threats
natural_threats = """
**Natural Threats**:
- Space Weather Events
- Cosmic Radiation
- Micrometeoroids and Space Dust
"""
full_threat_kb = space_threat_taxonomy + "\n" + natural_threats

# === LOAD THREAT TYPE MAPPING ===
threat_mapping_df = pd.read_excel("/content/ThreatType_Mapping.xlsx")

# === HELPER FUNCTION: QUERY MODEL WITH RETRY ===
def query_model(prompt, client, retries=1):
    for attempt in range(retries + 1):
        try:
            print(f"\nüöÄ Sending prompt (length={len(prompt)} chars)...")
            response = client.chat.completions.create(
                model="deepseek/deepseek-chat:free",
                messages=[{"role": "system", "content": "You are an expert in space cybersecurity and intelligence analysis."},
                          {"role": "user", "content": prompt}],
                stream=False,
                temperature=0.4
            )
            content = response.choices[0].message.content.strip()
            if not content:
                raise ValueError("Empty response from model.")
            return content
        except Exception as e:
            print(f"‚ö†Ô∏è Attempt {attempt + 1} failed: {e}")
            if attempt == retries:
                return f"<<ERROR: {str(e)}>>"
            time.sleep(5)

# === FUNCTION TO GET BEST MATCHING THREAT BASED ON COMMON TERMS INCLUDING INSTANCES ===
def get_best_matching_threat(description):
    matches = []
    for _, row in threat_mapping_df.iterrows():
        enisa_class = row['ENISA class']
        list_1_threat = row['List 1 Threat']
        relation = row['Relation']
        explanation = row['Explanation']
        instances = str(row.get('Instances', ''))

        keywords = [enisa_class, list_1_threat] + [i.strip() for i in instances.split(',') if i.strip()]
        if any(term.lower() in description.lower() for term in keywords):
            matches.append((enisa_class, list_1_threat, relation, explanation, instances))

    return matches if matches else None

# === MAIN PROCESSING LOOP ===
raw_responses = []
clients = [client1, client2, client3, client4, client5, client6, client7]
client_names = ['client1', 'client2', 'client3', 'client4', 'client5', 'client6', 'client7']
quota_exceeded_clients = set()

for idx in range(0, len(df)):
    row = df.iloc[idx]
    try:
        text = str(row['description'])
        lang = detect(text)
        matching_threats = get_best_matching_threat(text)

        # Prepare threat_str properly
        if matching_threats:
            threat_str = "\n".join(
                [f"- ENISA Class: {t[0]}, List 1 Threat: {t[1]}, Relation: {t[2]}, Explanation: {t[3]}, Instances: {t[4]}"
                 for t in matching_threats]
            )
        else:
            threat_str = "N/A"

        # Pick client
        available_clients = [c for i, c in enumerate(clients) if client_names[i] not in quota_exceeded_clients]
        if not available_clients:
            client = client1
            print("‚ö†Ô∏è All secondary APIs exhausted. Using client1 only.")
        else:
            client = available_clients[idx % len(available_clients)]

        # Prompt variant condition
        prompt_variant_condition = False

        if prompt_variant_condition:
            prompt = f"""
You are an expert in space threats. The task is to classify the provided description of a space-related event or threat.
**IMPORTANT**: Only use vocabulary from the knowledge base for technical threats, and terminology from hybrid_df for non-technical ones.
**IMPORTANT**: If the news text is just about suppositions, or you cannot be sure, prefer mapping vulnerabilities and capabilities, instead of categories and classes.
Given the following knowledge base and event description, classify the event by matching it to relevant threats:

Knowledge Base:
{full_threat_kb}

Threat Mapping (Matching Threats):
{threat_str}

Event Description:
{text}

Classification:
"""
        else:
            prompt = f"""
You are an expert in space threats, technical (cyber-kinetic-electromagnetic) and non-technical hybrid threats (economic/legal/cognitive war, etc..). The task is to classify the provided description from news of a space-related events or threats to support the decision-making of defence agencies.
**IMPORTANT**: Only use vocabulary from the knowledge base for technical threats, and terminology from hybrid_df for non-technical ones.
**IMPORTANT**: If the description is just about general suppositions, or you cannot be sure, do not risk inferring and saying the false.
Given the following knowledge base and event description, classify the event by matching it to relevant threats:

Knowledge Base:
{full_threat_kb}

Event Description:
{text}

Classification:
"""

        prompt += f"""
**Key Points:**
- [Summarize key points from the news text that indicate threat relevance and classification]
- Please use only the taxonomy terminology:
- for non-technical threats {hybrid_threats_text}
- for technical threats {full_threat_kb}
- You can be supported in Threat Mapping (Matching Threats) {threat_str}

**Confidence Evaluation Rules** (for assigning High / Medium / Low):
- **High**: The threat is explicitly confirmed or demonstrated in the text (e.g., direct statements of attacks, screenshots, or operational impact).
- **Medium**: The text implies or strongly suggests the threat but lacks direct confirmation or specific technical details.
- **Low**: The threat is speculative, hypothetical, denied by authoritative sources, or mentioned only as a possibility without supporting evidence.

Always pair confidence with specific **evidence** from the text (quote or paraphrased).

---

**Important notes to mitigate classification confusion when using taxonomy and instances:**

- The taxonomy classes and instances can overlap in terminology or granularity; ensure clear distinction between broad **classes** and specific **instances** when labeling.
- The relations **Direct**, **Indirect**, and **Mentioned** reflect levels of confidence and explicitness in the threat description; consider them carefully in the classification reasoning.
- When multiple instances appear within the same class, avoid ambiguous or overlapping labels by referencing the hierarchy and context.
- Be mindful that natural language in the news may use synonyms or varied terminology; align classifications strictly to the taxonomy vocabulary.
- If uncertainty remains high, prefer mapping to **vulnerabilities and capabilities** rather than forcing a direct class or instance label.
- Clearly separate **technical** and **non-technical (hybrid)** threat vocabularies.
- Always justify your classification with concrete **evidence** and **confidence levels** following the rules above.

---

Format output exactly like this (now including confidence and evidence for each threat class):
<<<RESPONSE_START>>>
1. Are there space-related issues? <Yes/No>
2. Is it a threat, attack, incident, or None? (Consider an incident something that happened by mistake; while an attack a voluntary violent action. A threat is something that can devolp in an attack or incident. But if the threat is too general, skip to vulnerabilties): <...>
3. Are the threats technical, or non-technical, or both?: <...>
4. For non-technical ones, which are the Hybrid Threat Types if present: <...>
5. for technical ones: All threats' **categories** from taxonomy that apply: <...>
6. Consequently for each of the previous, which **classes** **only** using vocabulary from **classes** in taxonomy: <...>
7. Term or technology in the analyzed text that retrieved the classed: <...>
8. Does the text provide enough information to retrieve threat **classes** classification? <Yes enough/Not enough>
9. Targeted Segments: <...>
10. Space-related vulnerability?: <Yes + explaination/No>
11. Space-related capability?: <Yes + explaination/No>
12. Lifecycle Phases Affected: <1, 2, 3, 4, 5, 6, 7,>
13. CIA Triad Affected: <C, I, A>
14. Detected Language: <...>
15. Language tone: <...>
16. Polarized?: <...>
17. Fictional?: <...>
18. Claim presence or illogic? <Claim, Illogic + explaination>
19. Reasoning for threat categories: <...>
20. Reasoning for threat classes: <...>
21. For each threat class, provide:
    - a. Confidence Level (High / Medium / Low) based on the strength of evidence in the text.
    - b. Textual evidence (quote or paraphrased) justifying the classification.
<<<RESPONSE_END>>>

Hybrid Threat Categories (from Hybrid Threats.xlsx):
{hybrid_threats_text}

Knowledge base:
{ground_kb}
{space_kb}
{user_kb}
{hr_kb}
{full_threat_kb}

News text to analyze:
{text}
"""

        print(f"üîç Prompt preview:\n{prompt[:500]}...\n{'-' * 60}")

        # Query model
        try:
            content = query_model(prompt, client, retries=1)
        except Exception as e:
            if "quota" in str(e).lower() or "limit" in str(e).lower():
                name = client_names[clients.index(client)]
                quota_exceeded_clients.add(name)
                print(f"‚ùå API limit reached for {name}, removing from rotation.")
                client = client1
                content = query_model(prompt, client, retries=1)
            else:
                raise

        # Post-processing of content
        try:
            if "8." in content and "6." in content:
                q8_line = next(line for line in content.splitlines() if line.strip().startswith("8."))
                if "Not enough" in q8_line:
                    content_lines = content.splitlines()
                    for i, line in enumerate(content_lines):
                        if line.strip().startswith("6."):
                            content_lines[i] = "6. Consequently for each of the previous, which **classes** **only** using vocabulary from **classes** in taxonomy: <skip>"
                            break
                    content = "\n".join(content_lines)
        except Exception as e:
            print(f"‚ö†Ô∏è Post-processing failed: {e}")

        full_output = f"<<<RESPONSE_START>>>\nDetected Language: {lang}\n{content}\n<<<RESPONSE_END>>>"
        print(f"\n‚úÖ Row {idx + 1} done:\n{full_output}\n{'=' * 80}")
        raw_responses.append(full_output)

        df.loc[idx, 'raw_resp'] = full_output
        df.to_csv('/content/gdelt2022_v3.csv', index=False)

        time.sleep(20)

    except Exception as e:
        print(f"‚ùå Error at row {idx + 1}: {e}")
        err_output = f"<<<RESPONSE_START>>>\nError: {str(e)}\n<<<RESPONSE_END>>>"
        raw_responses.append(err_output)

        df.loc[idx, 'raw_resp'] = err_output
        df.to_csv('/content/gdelt2022_v3.csv', index=False)

#just with one API

# INSTALL LIBRARIES
!pip install openai langdetect pandas openpyxl

import pandas as pd
import time
from openai import OpenAI
from langdetect import detect

# === CONFIG: THREE API CLIENTS ===
API_KEY_1 = "sk-obd97"

BASE_URL = "https://openrouter.ai/api/v1"

client1 = OpenAI(api_key=API_KEY_1, base_url=BASE_URL)


# === LOAD DATA ===
df = pd.read_excel("/content/gdelt2022_noBlanks.xlsx")
df['description'] = df['description'].fillna('')

# === LOAD KNOWLEDGE BASE FILES ===
with open('/content/ground_kb.txt', 'r') as f:
    ground_kb = f.read()

with open('/content/space_kb.txt', 'r') as f:
    space_kb = f.read()

with open('/content/user_kb.txt', 'r') as f:
    user_kb = f.read()

with open('/content/hr_kb.txt', 'r') as f:
    hr_kb = f.read()

with open('/content/Space_Threat_Taxonomy.txt', 'r') as f:
    space_threat_taxonomy = f.read()

# === LOAD HYBRID THREATS FROM EXCEL ===
hybrid_df = pd.read_excel("/content/Hybrid Threats.xlsx")
hybrid_threats_text = "\n".join(hybrid_df['Hybrid Threats'].dropna().astype(str).tolist())

# Add Natural Threats
natural_threats = """
**Natural Threats**:
- Space Weather Events
- Cosmic Radiation
- Micrometeoroids and Space Dust
"""
full_threat_kb = space_threat_taxonomy + "\n" + natural_threats

# === LOAD THREAT TYPE MAPPING ===
threat_mapping_df = pd.read_excel("/content/ThreatType_Mapping.xlsx")

# === HELPER FUNCTION: QUERY MODEL WITH RETRY ===
def query_model(prompt, client, retries=1):
    for attempt in range(retries + 1):
        try:
            print(f"\nüöÄ Sending prompt (length={len(prompt)} chars)...")
            response = client.chat.completions.create(
                model="deepseek/deepseek-chat:free",
                messages=[{"role": "system", "content": "You are an expert in space cybersecurity and intelligence analysis."},
                          {"role": "user", "content": prompt}],
                stream=False,
                temperature=0.4
            )
            content = response.choices[0].message.content.strip()
            if not content:
                raise ValueError("Empty response from model.")
            return content
        except Exception as e:
            print(f"‚ö†Ô∏è Attempt {attempt + 1} failed: {e}")
            if attempt == retries:
                return f"<<ERROR: {str(e)}>>"
            time.sleep(3)

# === FUNCTION TO GET BEST MATCHING THREAT BASED ON COMMON TERMS INCLUDING INSTANCES ===
def get_best_matching_threat(description):
    matches = []
    for _, row in threat_mapping_df.iterrows():
        enisa_class = row['ENISA class']
        list_1_threat = row['List 1 Threat']
        relation = row['Relation']
        explanation = row['Explanation']
        instances = str(row.get('Instances', ''))

        keywords = [enisa_class, list_1_threat] + [i.strip() for i in instances.split(',') if i.strip()]
        if any(term.lower() in description.lower() for term in keywords):
            matches.append((enisa_class, list_1_threat, relation, explanation, instances))

    return matches if matches else None

# === MAIN PROCESSING LOOP ===
raw_responses = []

for idx in range(0, len(df)):
    row = df.iloc[idx]
    try:
        text = str(row['description'])
        lang = detect(text)
        matching_threats = get_best_matching_threat(text)

        threat_str = ""
        if matching_threats:
            threat_str = "\n".join([
                f"- ENISA class: {x[0]}, List 1 Threat: {x[1]}, Relation: {x[2]}, Explanation: {x[3]}, Instances: {x[4]}"
                for x in matching_threats
            ])

        # Example condition placeholder - replace with your real logic if any
        prompt_variant_condition = False

        if prompt_variant_condition:
            prompt = f"""
You are an expert in space threats. The task is to classify the provided description of a space-related event or threat.
**IMPORTANT**: Only use vocabulary from the knowledge base for technical threats, and terminology from hybrid_df for non-technical ones.
**IMPORTANT**: If the news text is just about suppositions, or you cannot be sure, prefer mapping vulnerabilities and capabilities, instead of categories and classes.
Given the following knowledge base and event description, classify the event by matching it to relevant threats:

Knowledge Base:
{full_threat_kb}

Threat Mapping (Matching Threats):
{threat_str}

Event Description:
{text}

Classification:
"""
        else:
            prompt = f"""
You are an expert in space threats, technical (cyber-kinetic-electromagnetic) and non-technical hybrid threats (economic/legal/cognitive war, etc..). The task is to classify the provided description from news of a space-related events or threats to support the decision-making of defence agencies.
**IMPORTANT**: Only use vocabulary from the knowledge base for technical threats, and terminology from hybrid_df for non-technical ones.
**IMPORTANT**: If the description is just about general suppositions, or you cannot be sure, do not risk inferring and saying the false.
Given the following knowledge base and event description, classify the event by matching it to relevant threats:

Knowledge Base:
{full_threat_kb}

Event Description:
{text}

Classification:
"""

        prompt += f"""
**Key Points:**
- [Summarize key points from the news text that indicate threat relevance and classification]
- Please use only the taxonomy terminology:
- for non-technical threats {hybrid_threats_text}
- for technical threats {full_threat_kb}
- You can be supported in Threat Mapping (Matching Threats) {threat_str if matching_threats else 'N/A'}

**Confidence Evaluation Rules** (for assigning High / Medium / Low):
- **High**: The threat is explicitly confirmed or demonstrated in the text (e.g., direct statements of attacks, screenshots, or operational impact).
- **Medium**: The text implies or strongly suggests the threat but lacks direct confirmation or specific technical details.
- **Low**: The threat is speculative, hypothetical, denied by authoritative sources, or mentioned only as a possibility without supporting evidence.

Always pair confidence with specific **evidence** from the text (quote or paraphrased).

---

**Important notes to mitigate classification confusion when using taxonomy and instances:**

- The taxonomy classes and instances can overlap in terminology or granularity; ensure clear distinction between broad **classes** and specific **instances** when labeling.
- The relations **Direct**, **Indirect**, and **Mentioned** reflect levels of confidence and explicitness in the threat description; consider them carefully in the classification reasoning.
- When multiple instances appear within the same class, avoid ambiguous or overlapping labels by referencing the hierarchy and context.
- Be mindful that natural language in the news may use synonyms or varied terminology; align classifications strictly to the taxonomy vocabulary.
- If uncertainty remains high, prefer mapping to **vulnerabilities and capabilities** rather than forcing a direct class or instance label.
- Clearly separate **technical** and **non-technical (hybrid)** threat vocabularies.
- Always justify your classification with concrete **evidence** and **confidence levels** following the rules above.

---

Format output exactly like this (now including confidence and evidence for each threat class):
<<<RESPONSE_START>>>
1. Are there space-related issues? <Yes/No>
2. Is it a threat, attack, incident, or None? (Consider an incident something that happened by mistake; while an attack a voluntary violent action. A threat is something that can devolp in an attack or incident. But if the threat is too general, skip to vulnerabilties): <...>
3. Are the threats technical, or non-technical, or both?: <...>
4. For non-technical ones, which are the Hybrid Threat Types if present: <...>
5. for technical ones: All threats' **categories** from taxonomy that apply: <...>
6. Consequently for each of the previous, which **classes** **only** using vocabulary from **classes** in taxonomy: <...>
7. Term or technology in the analyzed text that retrieved the classed: <...>
8. Does the text provide enough information to retrieve threat **classes** classification? <Yes enough/Not enough>
9. Targeted Segments: <...>
10. Space-related vulnerability?: <Yes + explaination/No>
11. Space-related capability?: <Yes + explaination/No>
12. Lifecycle Phases Affected: <1, 2, 3, 4, 5, 6, 7,>
13. CIA Triad Affected: <C, I, A>
14. Detected Language: <...>
15. Language tone: <...>
16. Polarized?: <...>
17. Fictional?: <...>
18. Claim presence or illogic? <Claim, Illogic + explaination>
19. Reasoning for threat categories: <...>
20. Reasoning for threat classes: <...>
21. For each threat class, provide:
    - a. Confidence Level (High / Medium / Low) based on the strength of evidence in the text.
    - b. Textual evidence (quote or paraphrased) justifying the classification.
<<<RESPONSE_END>>>

Hybrid Threat Categories (from Hybrid Threats.xlsx):
{hybrid_threats_text}

Knowledge base:
{ground_kb}
{space_kb}
{user_kb}
{hr_kb}
{full_threat_kb}

News text to analyze:
{text}
"""

        # Preview prompt to debug
        print(f"üîç Prompt preview:\n{prompt[:500]}...\n{'-' * 60}")

        # Use only client1
        content = query_model(prompt, client1, retries=1)

        # Post-process content if needed
        try:
            if "8." in content and "6." in content:
                q8_line = next(line for line in content.splitlines() if line.strip().startswith("8."))
                if "Not enough" in q8_line:
                    content_lines = content.splitlines()
                    for i, line in enumerate(content_lines):
                        if line.strip().startswith("6."):
                            content_lines[i] = "6. Consequently for each of the previous, which **classes** **only** using vocabulary from **classes** in taxonomy: <skip>"
                            break
                    content = "\n".join(content_lines)
        except Exception as e:
            print(f"‚ö†Ô∏è Post-processing failed: {e}")

        full_output = f"<<<RESPONSE_START>>>\nDetected Language: {lang}\n{content}\n<<<RESPONSE_END>>>"
        print(f"\n‚úÖ Row {idx + 1} done:\n{full_output}\n{'=' * 80}")
        raw_responses.append(full_output)

        # Save progress
        df.loc[idx, 'raw_resp'] = full_output
        df.to_csv('/content/gdelt2022_v9.csv', index=False)

        time.sleep(10)

    except Exception as e:
        print(f"‚ùå Error at row {idx + 1}: {e}")
        err_output = f"<<<RESPONSE_START>>>\nError: {str(e)}\n<<<RESPONSE_END>>>"
        raw_responses.append(err_output)

        # Save progress after error
        df.loc[idx, 'raw_resp'] = err_output
        df.to_csv('/content/gdelt2022_v9.csv', index=False)

#EMM One API, Addition of attacker country and target

# INSTALL LIBRARIES
!pip install openai langdetect pandas openpyxl

import pandas as pd
import time
from openai import OpenAI
from langdetect import detect

# === CONFIG: THREE API CLIENTS ===
API_KEY_1 = "sk-d97"

BASE_URL = "https://openrouter.ai/api/v1"

client1 = OpenAI(api_key=API_KEY_1, base_url=BASE_URL)


# === LOAD DATA ===
df = pd.read_excel("/content/EMM_complete_noBlanks.xlsx")
df['description'] = df['description'].fillna('')

# === LOAD KNOWLEDGE BASE FILES ===
with open('/content/ground_kb.txt', 'r') as f:
    ground_kb = f.read()

with open('/content/space_kb.txt', 'r') as f:
    space_kb = f.read()

with open('/content/user_kb.txt', 'r') as f:
    user_kb = f.read()

with open('/content/hr_kb.txt', 'r') as f:
    hr_kb = f.read()

with open('/content/Space_Threat_Taxonomy.txt', 'r') as f:
    space_threat_taxonomy = f.read()

# === LOAD HYBRID THREATS FROM EXCEL ===
hybrid_df = pd.read_excel("/content/Hybrid Threats.xlsx")
hybrid_threats_text = "\n".join(hybrid_df['Hybrid Threats'].dropna().astype(str).tolist())

# Add Natural Threats
natural_threats = """
**Natural Threats**:
- Space Weather Events
- Cosmic Radiation
- Micrometeoroids and Space Dust
"""
full_threat_kb = space_threat_taxonomy + "\n" + natural_threats

# === LOAD THREAT TYPE MAPPING ===
threat_mapping_df = pd.read_excel("/content/ThreatType_Mapping.xlsx")

# === HELPER FUNCTION: QUERY MODEL WITH RETRY ===
def query_model(prompt, client, retries=1):
    for attempt in range(retries + 1):
        try:
            print(f"\nüöÄ Sending prompt (length={len(prompt)} chars)...")
            response = client.chat.completions.create(
                model="deepseek/deepseek-chat:free",
                messages=[{"role": "system", "content": "You are an expert in space cybersecurity and intelligence analysis."},
                          {"role": "user", "content": prompt}],
                stream=False,
                temperature=0.4
            )
            content = response.choices[0].message.content.strip()
            if not content:
                raise ValueError("Empty response from model.")
            return content
        except Exception as e:
            print(f"‚ö†Ô∏è Attempt {attempt + 1} failed: {e}")
            if attempt == retries:
                return f"<<ERROR: {str(e)}>>"
            time.sleep(3)

# === FUNCTION TO GET BEST MATCHING THREAT BASED ON COMMON TERMS INCLUDING INSTANCES ===
def get_best_matching_threat(description):
    matches = []
    for _, row in threat_mapping_df.iterrows():
        enisa_class = row['ENISA class']
        list_1_threat = row['List 1 Threat']
        relation = row['Relation']
        explanation = row['Explanation']
        instances = str(row.get('Instances', ''))

        keywords = [enisa_class, list_1_threat] + [i.strip() for i in instances.split(',') if i.strip()]
        if any(term.lower() in description.lower() for term in keywords):
            matches.append((enisa_class, list_1_threat, relation, explanation, instances))

    return matches if matches else None

# === MAIN PROCESSING LOOP ===
raw_responses = []

for idx in range(0, len(df)):
    row = df.iloc[idx]
    try:
        text = str(row['description'])
        lang = detect(text)
        matching_threats = get_best_matching_threat(text)

        threat_str = ""
        if matching_threats:
            threat_str = "\n".join([
                f"- ENISA class: {x[0]}, List 1 Threat: {x[1]}, Relation: {x[2]}, Explanation: {x[3]}, Instances: {x[4]}"
                for x in matching_threats
            ])

        # Example condition placeholder - replace with your real logic if any
        prompt_variant_condition = False

        if prompt_variant_condition:
            prompt = f"""
You are an expert in space threats. The task is to classify the provided description of a space-related event or threat.
**IMPORTANT**: Only use vocabulary from the knowledge base for technical threats, and terminology from hybrid_df for non-technical ones.
**IMPORTANT**: If the news text is just about suppositions, or you cannot be sure, prefer mapping vulnerabilities and capabilities, instead of categories and classes.
Given the following knowledge base and event description, classify the event by matching it to relevant threats:

Knowledge Base:
{full_threat_kb}

Threat Mapping (Matching Threats):
{threat_str}

Event Description:
{text}

Classification:
"""
        else:
            prompt = f"""
You are an expert in space threats, technical (cyber-kinetic-electromagnetic) and non-technical hybrid threats (economic/legal/cognitive war, etc..). The task is to classify the provided description from news of a space-related events or threats to support the decision-making of defence agencies.
**IMPORTANT**: Only use vocabulary from the knowledge base for technical threats, and terminology from hybrid_df for non-technical ones.
**IMPORTANT**: If the description is just about general suppositions, or you cannot be sure, do not risk inferring and saying the false.
Given the following knowledge base and event description, classify the event by matching it to relevant threats:

Knowledge Base:
{full_threat_kb}

Event Description:
{text}

Classification:
"""

        prompt += f"""
**Key Points:**
- [Summarize key points from the news text that indicate threat relevance and classification]
- Please use only the taxonomy terminology:
- for non-technical threats {hybrid_threats_text}
- for technical threats {full_threat_kb}
- You can be supported in Threat Mapping (Matching Threats) {threat_str if matching_threats else 'N/A'}

**Confidence Evaluation Rules** (for assigning High / Medium / Low):
- **High**: The threat is explicitly confirmed or demonstrated in the text (e.g., direct statements of attacks, screenshots, or operational impact).
- **Medium**: The text implies or strongly suggests the threat but lacks direct confirmation or specific technical details.
- **Low**: The threat is speculative, hypothetical, denied by authoritative sources, or mentioned only as a possibility without supporting evidence.

Always pair confidence with specific **evidence** from the text (quote or paraphrased).

---

**Important notes to mitigate classification confusion when using taxonomy and instances:**

- The taxonomy classes and instances can overlap in terminology or granularity; ensure clear distinction between broad **classes** and specific **instances** when labeling.
- The relations **Direct**, **Indirect**, and **Mentioned** reflect levels of confidence and explicitness in the threat description; consider them carefully in the classification reasoning.
- When multiple instances appear within the same class, avoid ambiguous or overlapping labels by referencing the hierarchy and context.
- Be mindful that natural language in the news may use synonyms or varied terminology; align classifications strictly to the taxonomy vocabulary.
- If uncertainty remains high, prefer mapping to **vulnerabilities and capabilities** rather than forcing a direct class or instance label.
- Clearly separate **technical** and **non-technical (hybrid)** threat vocabularies.
- Always justify your classification with concrete **evidence** and **confidence levels** following the rules above.
- Use the short official English name (e.g., United States, Russia, China, United Kingdom). Do not use abbreviations like "USA" or "UK", or long forms like "The United States of America". This standard applies to both attacking and target countries.
- Provide all raw_responses in English, even if the news text is in any other language. Use your multilingual skills for the analysis, but provide responses in English, also in reasonings or textual evidences.
- Non-Latin Scripts: If names (countries, entities, or people) are originally written in non-Latin scripts (e.g., Chinese, Japanese, Arabic, Cyrillic), provide a standard Romanized version (Latin alphabet). Use pinyin for Chinese names (e.g., Zhongguo for China). Use romaji for Japanese names (e.g., Nihon for Japan). Do not include characters from non-Latin scripts
---

Format output exactly like this (now including confidence and evidence for each threat class). Analyse with your multilingual skills, reply in in English:
<<<RESPONSE_START>>>
1. Are there space-related issues? <Yes/No>
2. Is it a threat, attack, incident, or None? (Consider an incident something that happened by mistake; while an attack a voluntary violent action. A threat is something that can devolp in an attack or incident. But if the threat is too general, skip to vulnerabilties): <...>
3. Are the threats technical, or non-technical, or both?: <...>
4. For non-technical ones, which are the Hybrid Threat Types if present: <...>
5. for technical ones: All threats' **categories** from taxonomy that apply: <...>
6. Consequently for each of the previous, which **classes** **only** using vocabulary from **classes** in taxonomy: <...>
7. Term or technology in the analyzed text that retrieved the classed: <...>
8. Does the text provide enough information to retrieve threat **classes** classification? <Yes enough/Not enough>
9. Targeted Segments: <...>
10. Space-related vulnerability?: <Yes + explaination/No>
11. Space-related capability?: <Yes + explaination/No>
12. Lifecycle Phases Affected: <1, 2, 3, 4, 5, 6, 7,>
13. CIA Triad Affected: <C, I, A>
14. Detected Language: <...>
15. Language tone: <...>
16. Polarized?: <...>
17. Fictional?: <...>
18. Claim presence or illogic? <Claim, Illogic + explaination>
19. Reasoning for threat categories: <...>
20. Reasoning for threat classes: <...>
21. For each threat class, provide:
    - a. Confidence Level (High / Medium / Low) based on the strength of evidence in the text.
    - b. Textual evidence (quote or paraphrased) justifying the classification.
22. Which is the main attacking country? <...>
23. Are there secondary attacking countries? If yes, which ones? <...>
24. Which category is the malicious actor from? for example: politics, hacking, military, etc...: <...>
25. Malicious actor's name if present: <...>
26. Which is the primary target country? <...>
27. Are there secondary target countries? If yes, which ones? <...>
28. Which typology is the targeted entity? for example infrastructure, satellite item, company: <...>
29. target actor's name, if present: <...>
30. What type of source is it? scientific or research paper, white paper, essay, editorial, or news and events-related information (e.g incident, attack?): <...>
<<<RESPONSE_END>>>

Hybrid Threat Categories (from Hybrid Threats.xlsx):
{hybrid_threats_text}

Knowledge base:
{ground_kb}
{space_kb}
{user_kb}
{hr_kb}
{full_threat_kb}

News text to analyze:
{text}
"""

        # Preview prompt to debug
        print(f"üîç Prompt preview:\n{prompt[:500]}...\n{'-' * 60}")

        # Use only client1
        content = query_model(prompt, client1, retries=1)

        # Post-process content if needed
        try:
            if "8." in content and "6." in content:
                q8_line = next(line for line in content.splitlines() if line.strip().startswith("8."))
                if "Not enough" in q8_line:
                    content_lines = content.splitlines()
                    for i, line in enumerate(content_lines):
                        if line.strip().startswith("6."):
                            content_lines[i] = "6. Consequently for each of the previous, which **classes** **only** using vocabulary from **classes** in taxonomy: <skip>"
                            break
                    content = "\n".join(content_lines)
        except Exception as e:
            print(f"‚ö†Ô∏è Post-processing failed: {e}")

        full_output = f"<<<RESPONSE_START>>>\nDetected Language: {lang}\n{content}\n<<<RESPONSE_END>>>"
        print(f"\n‚úÖ Row {idx + 1} done:\n{full_output}\n{'=' * 80}")
        raw_responses.append(full_output)

        # Save progress
        df.loc[idx, 'raw_resp'] = full_output
        df.to_csv('/content/emm_2025_v07.csv', index=False)

        time.sleep(10)

    except Exception as e:
        print(f"‚ùå Error at row {idx + 1}: {e}")
        err_output = f"<<<RESPONSE_START>>>\nError: {str(e)}\n<<<RESPONSE_END>>>"
        raw_responses.append(err_output)

        # Save progress after error
        df.loc[idx, 'raw_resp'] = err_output
        df.to_csv('/content/emm_2025_v07.csv', index=False)

#llama 3 3 70

# INSTALL LIBRARIES
!pip install openai langdetect pandas openpyxl

import pandas as pd
import time
from openai import OpenAI
from langdetect import detect

# === CONFIG: THREE API CLIENTS ===6d5
API_KEY_1 = "sk-o13c"
API_KEY_2 = "sk-8d5ac"
API_KEY_3 = "sk9bc"
BASE_URL = "https://openrouter.ai/api/v1"

client1 = OpenAI(api_key=API_KEY_1, base_url=BASE_URL)
client2 = OpenAI(api_key=API_KEY_2, base_url=BASE_URL)
client3 = OpenAI(api_key=API_KEY_3, base_url=BASE_URL)

# === LOAD DATA ===
df = pd.read_excel("/content/mancanti.xlsx")
df['description'] = df['description'].fillna('')

# === LOAD KNOWLEDGE BASE FILES ===
with open('/content/ground_kb.txt', 'r') as f:
    ground_kb = f.read()

with open('/content/space_kb.txt', 'r') as f:
    space_kb = f.read()

with open('/content/user_kb.txt', 'r') as f:
    user_kb = f.read()

with open('/content/hr_kb.txt', 'r') as f:
    hr_kb = f.read()

with open('/content/Space_Threat_Taxonomy.txt', 'r') as f:
    space_threat_taxonomy = f.read()

# === LOAD HYBRID THREATS FROM EXCEL ===
hybrid_df = pd.read_excel("/content/Hybrid Threats.xlsx")
hybrid_threats_text = "\n".join(hybrid_df['Hybrid Threats'].dropna().astype(str).tolist())

# Add Natural Threats
natural_threats = """
**Natural Threats**:
- Space Weather Events
- Cosmic Radiation
- Micrometeoroids and Space Dust
"""
full_threat_kb = space_threat_taxonomy + "\n" + natural_threats

# === LOAD THREAT TYPE MAPPING ===
threat_mapping_df = pd.read_excel("/content/ThreatType_Mapping.xlsx")

def query_model(prompt, client, model="meta-llama/llama-3.3-70b-instruct:free", retries=1):
    for attempt in range(retries + 1):
        try:
            print(f"\nüöÄ Sending prompt (length={len(prompt)} chars) to model: {model} ...")
            response = client.chat.completions.create(
                model=model,
                messages=[
                    {"role": "system", "content": "You are an expert in space cybersecurity and intelligence analysis."},
                    {"role": "user", "content": prompt}
                ],
                stream=False,
                temperature=0.4,
                extra_headers={
                    "HTTP-Referer": "https://your-site.example",  # Optional: For OpenRouter rankings
                    "X-Title": "SpaceThreatAnalyzer",              # Optional: For OpenRouter rankings
                },
                extra_body={}
            )
            content = response.choices[0].message.content.strip()
            if not content:
                raise ValueError("Empty response from model.")
            return content
        except Exception as e:
            print(f"‚ö†Ô∏è Attempt {attempt + 1} failed: {e}")
            if attempt == retries:
                return f"<<ERROR: {str(e)}>>"
            time.sleep(3)

# === FUNCTION TO GET BEST MATCHING THREAT BASED ON COMMON TERMS INCLUDING INSTANCES ===
def get_best_matching_threat(description):
    matches = []
    for _, row in threat_mapping_df.iterrows():
        enisa_class = row['ENISA class']
        list_1_threat = row['List 1 Threat']
        relation = row['Relation']
        explanation = row['Explanation']
        instances = str(row.get('Instances', ''))

        keywords = [enisa_class, list_1_threat] + [i.strip() for i in instances.split(',') if i.strip()]
        if any(term.lower() in description.lower() for term in keywords):
            matches.append((enisa_class, list_1_threat, relation, explanation, instances))

    return matches if matches else None

# === MAIN PROCESSING LOOP ===
raw_responses = []
clients = [client1, client2, client3]

for idx in range(0, len(df)):
    row = df.iloc[idx]
    try:
        text = str(row['description'])
        lang = detect(text)
        matching_threats = get_best_matching_threat(text)

        if matching_threats:
            threat_str = "\n".join([
                f"ENISA Class: {enisa_class}, List 1 Threat: {list_1_threat}, Relation: {relation}, Explanation: {explanation}, Instances: {instances}"
                for enisa_class, list_1_threat, relation, explanation, instances in matching_threats
            ])
            prompt = f"""
You are an expert in space threats. The task is to classify the provided description of a space-related event or threat.
**IMPORTANT**: Only use vocabulary from the knowledge base for technical threats, and terminology from hybrid_df for non-technical ones.
**IMPORTANT**: If the news text is just about suppositions, or you cannot be sure, prefer mapping vulnerabilities and capabilities, instead of categories and classes.
Given the following knowledge base and event description, classify the event by matching it to relevant threats:

Knowledge Base:
{full_threat_kb}

Threat Mapping (Matching Threats):
{threat_str}

Event Description:
{text}

Classification:
"""
        else:
            prompt = f"""
You are an expert in space threats, technical (cyber-kinetic-electromagnetic) and non-technical hybrid threats (economic/legal/cognitive war, etc..). The task is to classify the provided description from news of a space-related events or threats to support the decision-making of defence agencies.
**IMPORTANT**: Only use vocabulary from the knowledge base for technical threats, and terminology from hybrid_df for non-technical ones.
**IMPORTANT**: If the description is just about general suppositions, or you cannot be sure, do not risk inferring and saying the false.
Given the following knowledge base and event description, classify the event by matching it to relevant threats:

Knowledge Base:
{full_threat_kb}

Event Description:
{text}

Classification:
"""

        # Append mitigation instructions
        prompt += f"""
**Key Points:**
- [Summarize key points from the news text that indicate threat relevance and classification]
- Please use only the taxonomy terminology:
- for non-technical threats {hybrid_threats_text}
- for technical threats {full_threat_kb}
- You can be supported in Threat Mapping (Matching Threats) {threat_str if matching_threats else 'N/A'}

**Confidence Evaluation Rules** (for assigning High / Medium / Low):
- **High**: The threat is explicitly confirmed or demonstrated in the text (e.g., direct statements of attacks, screenshots, or operational impact).
- **Medium**: The text implies or strongly suggests the threat but lacks direct confirmation or specific technical details.
- **Low**: The threat is speculative, hypothetical, denied by authoritative sources, or mentioned only as a possibility without supporting evidence.

Always pair confidence with specific **evidence** from the text (quote or paraphrased).

---

**Important notes to mitigate classification confusion when using taxonomy and instances:**

- The taxonomy classes and instances can overlap in terminology or granularity; ensure clear distinction between broad **classes** and specific **instances** when labeling.
- The relations **Direct**, **Indirect**, and **Mentioned** reflect levels of confidence and explicitness in the threat description; consider them carefully in the classification reasoning.
- When multiple instances appear within the same class, avoid ambiguous or overlapping labels by referencing the hierarchy and context.
- Be mindful that natural language in the news may use synonyms or varied terminology; align classifications strictly to the taxonomy vocabulary.
- If uncertainty remains high, prefer mapping to **vulnerabilities and capabilities** rather than forcing a direct class or instance label.
- Clearly separate **technical** and **non-technical (hybrid)** threat vocabularies.
- Always justify your classification with concrete **evidence** and **confidence levels** following the rules above.

---

Format output exactly like this (now including confidence and evidence for each threat class):
<<<RESPONSE_START>>>
1. Are there space-related issues? <Yes/No>
2. Is it a threat, attack, incident, or None? (Consider an incident something that happened by mistake; while an attack a voluntary violent action. A threat is something that can devolp in an attack or incident. But if the threat is too general, skip to vulnerabilties): <...>
3. Are the threats technical, or non-technical, or both?: <...>
4. For non-technical ones, which are the Hybrid Threat Types if present: <...>
5. for technical ones: All threats' **categories** from taxonomy that apply: <...>
6. Consequently for each of the previous, which **classes** **only** using vocabulary from **classes** in taxonomy: <...>
7. Term or technology in the analyzed text that retrieved the classed: <...>
8. Does the text provide enough information to retrieve threat **classes** classification? <Yes enough/Not enough>
9. Targeted Segments: <...>
10. Space-related vulnerability?: <Yes + explaination/No>
11. Space-related capability?: <Yes + explaination/No>
12. Lifecycle Phases Affected: <1, 2, 3, 4, 5, 6, 7,>
13. CIA Triad Affected: <C, I, A>
14. Detected Language: <...>
15. Language tone: <...>
16. Polarized?: <...>
17. Fictional?: <...>
18. Claim presence or illogic? <Claim, Illogic + explaination>
19. Reasoning for threat categories: <...>
20. Reasoning for threat classes: <...>
21. For each threat class, provide:
    - a. Confidence Level (High / Medium / Low) based on the strength of evidence in the text.
    - b. Textual evidence (quote or paraphrased) justifying the classification.
<<<RESPONSE_END>>>

Hybrid Threat Categories (from Hybrid Threats.xlsx):
{hybrid_threats_text}

Knowledge base:
{ground_kb}
{space_kb}
{user_kb}
{hr_kb}
{full_threat_kb}

News text to analyze:
{text}
"""

        print(f"üîç Prompt preview:\n{prompt[:500]}...\n{'-' * 60}")
        client = clients[idx % 3]
        content = query_model(prompt, client, model="meta-llama/llama-3.3-70b-instruct:free", retries=1)


        try:
            if "8." in content and "6." in content:
                q8_line = next(line for line in content.splitlines() if line.strip().startswith("8."))
                if "Not enough" in q8_line:
                    content_lines = content.splitlines()
                    for i, line in enumerate(content_lines):
                        if line.strip().startswith("6."):
                            content_lines[i] = "6. Consequently for each of the previous, which **classes** **only** using vocabulary from **classes** in taxonomy: <skip>"
                            break
                    content = "\n".join(content_lines)
        except Exception as e:
            print(f"‚ö†Ô∏è Post-processing failed: {e}")

        full_output = f"<<<RESPONSE_START>>>\nDetected Language: {lang}\n{content}\n<<<RESPONSE_END>>>"
        print(f"\n‚úÖ Row {idx + 1} done:\n{full_output}\n{'=' * 80}")
        raw_responses.append(full_output)
        time.sleep(10)

    except Exception as e:
        print(f"‚ùå Error at row {idx + 1}: {e}")
        raw_responses.append(f"<<<RESPONSE_START>>>\nError: {str(e)}\n<<<RESPONSE_END>>>")

# === SAVE OUTPUT ===
df['raw_resp'] = raw_responses
df.to_csv('llama_mancanti.csv', index=False)

# === DOWNLOAD (Colab only) ===
from google.colab import files
files.download('llama_mancanti.csv')



#now with gemini flash 2.0

# INSTALL LIBRARIES
!pip install openai langdetect pandas openpyxl

import pandas as pd
import time
from openai import OpenAI
from langdetect import detect
import signal
import sys


# === CONFIG: THREE API CLIENTS ===
API_KEY_1 = "sk-or-08e260"
API_KEY_2 = "sk-f62"
API_KEY_3 = "sbd822c"
BASE_URL = "https://openrouter.ai/api/v1"

client1 = OpenAI(api_key=API_KEY_1, base_url=BASE_URL)
client2 = OpenAI(api_key=API_KEY_2, base_url=BASE_URL)
client3 = OpenAI(api_key=API_KEY_3, base_url=BASE_URL)

# === LOAD DATA ===
df = pd.read_excel("/content/space_emm_189.xlsx")
df['description'] = df['description'].fillna('')

# === LOAD KNOWLEDGE BASE FILES ===
with open('/content/ground_kb.txt', 'r') as f:
    ground_kb = f.read()

with open('/content/space_kb.txt', 'r') as f:
    space_kb = f.read()

with open('/content/user_kb.txt', 'r') as f:
    user_kb = f.read()

with open('/content/hr_kb.txt', 'r') as f:
    hr_kb = f.read()

with open('/content/Space_Threat_Taxonomy.txt', 'r') as f:
    space_threat_taxonomy = f.read()

# === LOAD HYBRID THREATS FROM EXCEL ===
hybrid_df = pd.read_excel("/content/Hybrid Threats.xlsx")
hybrid_threats_text = "\n".join(hybrid_df['Hybrid Threats'].dropna().astype(str).tolist())

# Add Natural Threats
natural_threats = """
**Natural Threats**:
- Space Weather Events
- Cosmic Radiation
- Micrometeoroids and Space Dust
"""
full_threat_kb = space_threat_taxonomy + "\n" + natural_threats

# === LOAD THREAT TYPE MAPPING ===
threat_mapping_df = pd.read_excel("/content/ThreatType_Mapping.xlsx")

def query_model(prompt, client, model="google/gemini-2.0-flash-exp:free", retries=1):
    for attempt in range(retries + 1):
        try:
            print(f"\nüöÄ Sending prompt (length={len(prompt)} chars) to model: {model} ...")
            response = client.chat.completions.create(
                model=model,
                messages=[{"role": "user", "content": prompt}],
                stream=False,
                temperature=0.4,
                extra_headers={
                    "HTTP-Referer": "https://your-site.example",
                    "X-Title": "SpaceThreatAnalyzer",
                },
                extra_body={}
            )

            # Check if choices exist and are not empty
            if not hasattr(response, 'choices') or not response.choices:
                print("‚ö†Ô∏è Warning: No choices found in response.")
                raise ValueError("Empty choices list in response.")

            # Safely extract content
            content = response.choices[0].message.content.strip()
            if not content:
                raise ValueError("Empty response content from model.")

            return content

        except Exception as e:
            print(f"‚ö†Ô∏è Attempt {attempt + 1} failed: {e}")
            if attempt == retries:
                return f"<<ERROR: {str(e)}>>"
            time.sleep(5)


# === FUNCTION TO GET BEST MATCHING THREAT BASED ON COMMON TERMS INCLUDING INSTANCES ===
def get_best_matching_threat(description):
    matches = []
    for _, row in threat_mapping_df.iterrows():
        enisa_class = row['ENISA class']
        list_1_threat = row['List 1 Threat']
        relation = row['Relation']
        explanation = row['Explanation']
        instances = str(row.get('Instances', ''))

        keywords = [enisa_class, list_1_threat] + [i.strip() for i in instances.split(',') if i.strip()]
        if any(term.lower() in description.lower() for term in keywords):
            matches.append((enisa_class, list_1_threat, relation, explanation, instances))

    return matches if matches else None

# === MAIN PROCESSING LOOP ===
raw_responses = []
clients = [client1, client2, client3]

for idx in range(0, len(df)):
    row = df.iloc[idx]
    try:
        text = str(row['description'])
        lang = detect(text)
        matching_threats = get_best_matching_threat(text)

        if matching_threats:
            threat_str = "\n".join([
                f"ENISA Class: {enisa_class}, List 1 Threat: {list_1_threat}, Relation: {relation}, Explanation: {explanation}, Instances: {instances}"
                for enisa_class, list_1_threat, relation, explanation, instances in matching_threats
            ])
            prompt = f"""
You are an expert in space threats. The task is to classify the provided description of a space-related event or threat.
**IMPORTANT**: Only use vocabulary from the knowledge base for technical threats, and terminology from hybrid_df for non-technical ones.
**IMPORTANT**: If the news text is just about suppositions, or you cannot be sure, prefer mapping vulnerabilities and capabilities, instead of categories and classes.
Given the following knowledge base and event description, classify the event by matching it to relevant threats:

Knowledge Base:
{full_threat_kb}

Threat Mapping (Matching Threats):
{threat_str}

Event Description:
{text}

Classification:
"""
        else:
            prompt = f"""
You are an expert in space threats, technical (cyber-kinetic-electromagnetic) and non-technical hybrid threats (economic/legal/cognitive war, etc..). The task is to classify the provided description from news of a space-related events or threats to support the decision-making of defence agencies.
**IMPORTANT**: Only use vocabulary from the knowledge base for technical threats, and terminology from hybrid_df for non-technical ones.
**IMPORTANT**: If the description is just about general suppositions, or you cannot be sure, do not risk inferring and saying the false.
Given the following knowledge base and event description, classify the event by matching it to relevant threats:

Knowledge Base:
{full_threat_kb}

Event Description:
{text}

Classification:
"""

        # Append mitigation instructions
        prompt += f"""
**Key Points:**
- [Summarize key points from the news text that indicate threat relevance and classification]
- Please use only the taxonomy terminology:
- for non-technical threats {hybrid_threats_text}
- for technical threats {full_threat_kb}
- You can be supported in Threat Mapping (Matching Threats) {threat_str if matching_threats else 'N/A'}

**Confidence Evaluation Rules** (for assigning High / Medium / Low):
- **High**: The threat is explicitly confirmed or demonstrated in the text (e.g., direct statements of attacks, screenshots, or operational impact).
- **Medium**: The text implies or strongly suggests the threat but lacks direct confirmation or specific technical details.
- **Low**: The threat is speculative, hypothetical, denied by authoritative sources, or mentioned only as a possibility without supporting evidence.

Always pair confidence with specific **evidence** from the text (quote or paraphrased).

---

**Important notes to mitigate classification confusion when using taxonomy and instances:**

- The taxonomy classes and instances can overlap in terminology or granularity; ensure clear distinction between broad **classes** and specific **instances** when labeling.
- The relations **Direct**, **Indirect**, and **Mentioned** reflect levels of confidence and explicitness in the threat description; consider them carefully in the classification reasoning.
- When multiple instances appear within the same class, avoid ambiguous or overlapping labels by referencing the hierarchy and context.
- Be mindful that natural language in the news may use synonyms or varied terminology; align classifications strictly to the taxonomy vocabulary.
- If uncertainty remains high, prefer mapping to **vulnerabilities and capabilities** rather than forcing a direct class or instance label.
- Clearly separate **technical** and **non-technical (hybrid)** threat vocabularies.
- Always justify your classification with concrete **evidence** and **confidence levels** following the rules above.

---

Format output exactly like this (now including confidence and evidence for each threat class):
<<<RESPONSE_START>>>
1. Are there space-related issues? <Yes/No>
2. Is it a threat, attack, incident, or None? (Consider an incident something that happened by mistake; while an attack a voluntary violent action. A threat is something that can devolp in an attack or incident. But if the threat is too general, skip to vulnerabilties): <...>
3. Are the threats technical, or non-technical, or both?: <...>
4. For non-technical ones, which are the Hybrid Threat Types if present: <...>
5. for technical ones: All threats' **categories** from taxonomy that apply: <...>
6. Consequently for each of the previous, which **classes** **only** using vocabulary from **classes** in taxonomy: <...>
7. Term or technology in the analyzed text that retrieved the classed: <...>
8. Does the text provide enough information to retrieve threat **classes** classification? <Yes enough/Not enough>
9. Targeted Segments: <...>
10. Space-related vulnerability?: <Yes + explaination/No>
11. Space-related capability?: <Yes + explaination/No>
12. Lifecycle Phases Affected: <1, 2, 3, 4, 5, 6, 7,>
13. CIA Triad Affected: <C, I, A>
14. Detected Language: <...>
15. Language tone: <...>
16. Polarized?: <...>
17. Fictional?: <...>
18. Claim presence or illogic? <Claim, Illogic + explaination>
19. Reasoning for threat categories: <...>
20. Reasoning for threat classes: <...>
21. For each threat class, provide:
    - a. Confidence Level (High / Medium / Low) based on the strength of evidence in the text.
    - b. Textual evidence (quote or paraphrased) justifying the classification.
<<<RESPONSE_END>>>

Hybrid Threat Categories (from Hybrid Threats.xlsx):
{hybrid_threats_text}

Knowledge base:
{ground_kb}
{space_kb}
{user_kb}
{hr_kb}
{full_threat_kb}

News text to analyze:
{text}
"""

        print(f"üîç Prompt preview:\n{prompt[:500]}...\n{'-' * 60}")
        client = clients[idx % 3]
        content = query_model(prompt, client, model="google/gemini-2.0-flash-exp:free", retries=1)

        try:
            if "8." in content and "6." in content:
                q8_line = next(line for line in content.splitlines() if line.strip().startswith("8."))
                if "Not enough" in q8_line:
                    content_lines = content.splitlines()
                    for i, line in enumerate(content_lines):
                        if line.strip().startswith("6."):
                            content_lines[i] = "6. Consequently for each of the previous, which **classes** **only** using vocabulary from **classes** in taxonomy: <skip>"
                            break
                    content = "\n".join(content_lines)
        except Exception as e:
            print(f"‚ö†Ô∏è Post-processing failed: {e}")

        full_output = f"<<<RESPONSE_START>>>\nDetected Language: {lang}\n{content}\n<<<RESPONSE_END>>>"
        print(f"\n‚úÖ Row {idx + 1} done:\n{full_output}\n{'=' * 80}")
        raw_responses.append(full_output)
        time.sleep(10)

    except Exception as e:
        print(f"‚ùå Error at row {idx + 1}: {e}")
        raw_responses.append(f"<<<RESPONSE_START>>>\nError: {str(e)}\n<<<RESPONSE_END>>>")

# === SAVE OUTPUT ===
df['raw_resp'] = raw_responses
df.to_csv('gemini_flash_2.0_space_test.csv', index=False)

# === DOWNLOAD (Colab only) ===
from google.colab import files
files.download('gemini_flash_2.0_space_test.csv')



# INSTALL LIBRARIES
!pip install openai langdetect pandas openpyxl

import pandas as pd
import time
from openai import OpenAI
from langdetect import detect
import signal
import sys


# === CONFIG: THREE API CLIENTS ===
API_KEY_1 = "skb1"
#API_KEY_2 = "sk62"
#API_KEY_3 = "s2c"
BASE_URL = "https://openrouter.ai/api/v1"

client1 = OpenAI(api_key=API_KEY_1, base_url=BASE_URL)
#client2 = OpenAI(api_key=API_KEY_2, base_url=BASE_URL)
#client3 = OpenAI(api_key=API_KEY_3, base_url=BASE_URL)

# === LOAD DATA ===
df = pd.read_excel("/content/space_emm_189.xlsx")
df['description'] = df['description'].fillna('')

# === LOAD KNOWLEDGE BASE FILES ===
with open('/content/ground_kb.txt', 'r') as f:
    ground_kb = f.read()

with open('/content/space_kb.txt', 'r') as f:
    space_kb = f.read()

with open('/content/user_kb.txt', 'r') as f:
    user_kb = f.read()

with open('/content/hr_kb.txt', 'r') as f:
    hr_kb = f.read()

with open('/content/Space_Threat_Taxonomy.txt', 'r') as f:
    space_threat_taxonomy = f.read()

# === LOAD HYBRID THREATS FROM EXCEL ===
hybrid_df = pd.read_excel("/content/Hybrid Threats.xlsx")
hybrid_threats_text = "\n".join(hybrid_df['Hybrid Threats'].dropna().astype(str).tolist())

# Add Natural Threats
natural_threats = """
**Natural Threats**:
- Space Weather Events
- Cosmic Radiation
- Micrometeoroids and Space Dust
"""
full_threat_kb = space_threat_taxonomy + "\n" + natural_threats

# === LOAD THREAT TYPE MAPPING ===
threat_mapping_df = pd.read_excel("/content/ThreatType_Mapping.xlsx")

def query_model(prompt, client, model="google/gemini-2.0-flash-exp:free", retries=1):
    for attempt in range(retries + 1):
        try:
            print(f"\nüöÄ Sending prompt (length={len(prompt)} chars) to model: {model} ...")
            response = client.chat.completions.create(
                model=model,
                messages=[{"role": "user", "content": prompt}],
                stream=False,
                temperature=0.4,
                extra_headers={
                    "HTTP-Referer": "https://your-site.example",
                    "X-Title": "SpaceThreatAnalyzer",
                },
                extra_body={}
            )

            # Check if choices exist and are not empty
            if not hasattr(response, 'choices') or not response.choices:
                print("‚ö†Ô∏è Warning: No choices found in response.")
                raise ValueError("Empty choices list in response.")

            # Safely extract content
            content = response.choices[0].message.content.strip()
            if not content:
                raise ValueError("Empty response content from model.")

            return content

        except Exception as e:
            print(f"‚ö†Ô∏è Attempt {attempt + 1} failed: {e}")
            if attempt == retries:
                return f"<<ERROR: {str(e)}>>"
            time.sleep(15)


# === FUNCTION TO GET BEST MATCHING THREAT BASED ON COMMON TERMS INCLUDING INSTANCES ===
def get_best_matching_threat(description):
    matches = []
    for _, row in threat_mapping_df.iterrows():
        enisa_class = row['ENISA class']
        list_1_threat = row['List 1 Threat']
        relation = row['Relation']
        explanation = row['Explanation']
        instances = str(row.get('Instances', ''))

        keywords = [enisa_class, list_1_threat] + [i.strip() for i in instances.split(',') if i.strip()]
        if any(term.lower() in description.lower() for term in keywords):
            matches.append((enisa_class, list_1_threat, relation, explanation, instances))

    return matches if matches else None

# === MAIN PROCESSING LOOP ===
raw_responses = []
client = client1

for idx in range(0, len(df)):
    row = df.iloc[idx]
    try:
        text = str(row['description'])
        lang = detect(text)
        matching_threats = get_best_matching_threat(text)

        if matching_threats:
            threat_str = "\n".join([
                f"ENISA Class: {enisa_class}, List 1 Threat: {list_1_threat}, Relation: {relation}, Explanation: {explanation}, Instances: {instances}"
                for enisa_class, list_1_threat, relation, explanation, instances in matching_threats
            ])
            prompt = f"""
You are an expert in space threats. The task is to classify the provided description of a space-related event or threat.
**IMPORTANT**: Only use vocabulary from the knowledge base for technical threats, and terminology from hybrid_df for non-technical ones.
**IMPORTANT**: If the news text is just about suppositions, or you cannot be sure, prefer mapping vulnerabilities and capabilities, instead of categories and classes.
Given the following knowledge base and event description, classify the event by matching it to relevant threats:

Knowledge Base:
{full_threat_kb}

Threat Mapping (Matching Threats):
{threat_str}

Event Description:
{text}

Classification:
"""
        else:
            prompt = f"""
You are an expert in space threats, technical (cyber-kinetic-electromagnetic) and non-technical hybrid threats (economic/legal/cognitive war, etc..). The task is to classify the provided description from news of a space-related events or threats to support the decision-making of defence agencies.
**IMPORTANT**: Only use vocabulary from the knowledge base for technical threats, and terminology from hybrid_df for non-technical ones.
**IMPORTANT**: If the description is just about general suppositions, or you cannot be sure, do not risk inferring and saying the false.
Given the following knowledge base and event description, classify the event by matching it to relevant threats:

Knowledge Base:
{full_threat_kb}

Event Description:
{text}

Classification:
"""

        # Append mitigation instructions
        prompt += f"""
**Key Points:**
- [Summarize key points from the news text that indicate threat relevance and classification]
- Please use only the taxonomy terminology:
- for non-technical threats {hybrid_threats_text}
- for technical threats {full_threat_kb}
- You can be supported in Threat Mapping (Matching Threats) {threat_str if matching_threats else 'N/A'}

**Confidence Evaluation Rules** (for assigning High / Medium / Low):
- **High**: The threat is explicitly confirmed or demonstrated in the text (e.g., direct statements of attacks, screenshots, or operational impact).
- **Medium**: The text implies or strongly suggests the threat but lacks direct confirmation or specific technical details.
- **Low**: The threat is speculative, hypothetical, denied by authoritative sources, or mentioned only as a possibility without supporting evidence.

Always pair confidence with specific **evidence** from the text (quote or paraphrased).

---

**Important notes to mitigate classification confusion when using taxonomy and instances:**

- The taxonomy classes and instances can overlap in terminology or granularity; ensure clear distinction between broad **classes** and specific **instances** when labeling.
- The relations **Direct**, **Indirect**, and **Mentioned** reflect levels of confidence and explicitness in the threat description; consider them carefully in the classification reasoning.
- When multiple instances appear within the same class, avoid ambiguous or overlapping labels by referencing the hierarchy and context.
- Be mindful that natural language in the news may use synonyms or varied terminology; align classifications strictly to the taxonomy vocabulary.
- If uncertainty remains high, prefer mapping to **vulnerabilities and capabilities** rather than forcing a direct class or instance label.
- Clearly separate **technical** and **non-technical (hybrid)** threat vocabularies.
- Always justify your classification with concrete **evidence** and **confidence levels** following the rules above.

---

Format output exactly like this (now including confidence and evidence for each threat class):
<<<RESPONSE_START>>>
1. Are there space-related issues? <Yes/No>
2. Is it a threat, attack, incident, or None? (Consider an incident something that happened by mistake; while an attack a voluntary violent action. A threat is something that can devolp in an attack or incident. But if the threat is too general, skip to vulnerabilties): <...>
3. Are the threats technical, or non-technical, or both?: <...>
4. For non-technical ones, which are the Hybrid Threat Types if present: <...>
5. for technical ones: All threats' **categories** from taxonomy that apply: <...>
6. Consequently for each of the previous, all **classes** **only** using vocabulary from **classes** in taxonomy and mapping: <...>
7. Term or technology in the analyzed text that retrieved the classed: <...>
8. Does the text provide enough information to retrieve threat **classes** classification? <Yes enough/Not enough>
9. Targeted Segments: <...>
10. Space-related vulnerability?: <Yes + explaination/No>
11. Space-related capability?: <Yes + explaination/No>
12. Lifecycle Phases Affected: <1, 2, 3, 4, 5, 6, 7,>
13. CIA Triad Affected: <C, I, A>
14. Detected Language: <...>
15. Language tone: <...>
16. Polarized?: <...>
17. Fictional?: <...>
18. Claim presence or illogic? <Claim, Illogic + explaination>
19. Reasoning for threat categories: <...>
20. Reasoning for threat classes: <...>
21. For each threat class, provide:
    - a. Confidence Level (High / Medium / Low) based on the strength of evidence in the text.
    - b. Textual evidence (quote or paraphrased) justifying the classification.
<<<RESPONSE_END>>>

Hybrid Threat Categories (from Hybrid Threats.xlsx):
{hybrid_threats_text}

Knowledge base:
{ground_kb}
{space_kb}
{user_kb}
{hr_kb}
{full_threat_kb}

News text to analyze:
{text}
"""

        print(f"üîç Prompt preview:\n{prompt[:500]}...\n{'-' * 60}")
        client = client1
        content = query_model(prompt, client, model="google/gemini-2.0-flash-exp:free", retries=1)

        try:
            if "8." in content and "6." in content:
                q8_line = next(line for line in content.splitlines() if line.strip().startswith("8."))
                if "Not enough" in q8_line:
                    content_lines = content.splitlines()
                    for i, line in enumerate(content_lines):
                        if line.strip().startswith("6."):
                            content_lines[i] = "6. Consequently for each of the previous, which **classes** **only** using vocabulary from **classes** in taxonomy: <skip>"
                            break
                    content = "\n".join(content_lines)
        except Exception as e:
            print(f"‚ö†Ô∏è Post-processing failed: {e}")

        full_output = f"<<<RESPONSE_START>>>\nDetected Language: {lang}\n{content}\n<<<RESPONSE_END>>>"
        print(f"\n‚úÖ Row {idx + 1} done:\n{full_output}\n{'=' * 80}")
        raw_responses.append(full_output)
        time.sleep(30)

    except Exception as e:
        print(f"‚ùå Error at row {idx + 1}: {e}")
        raw_responses.append(f"<<<RESPONSE_START>>>\nError: {str(e)}\n<<<RESPONSE_END>>>")

# === SAVE OUTPUT ===
df['raw_resp'] = raw_responses
df.to_csv('gemini_flash_2.0_space_test.csv', index=False)

# === DOWNLOAD (Colab only) ===
from google.colab import files
files.download('gemini_flash_2.0_space_test.csv')

#preparo file pulito EMM x PowerBI

import pandas as pd
import re

# === Step 1: Load the Excel file === #
file_path = '/content/Emm_Post_official.xlsx'
df = pd.read_excel(file_path)

# === Step 2: Define targeted_segment keywords and create binary flags === #
segment_keywords = {
    'Space Segment': 'Space',
    'Ground Segment': 'Ground',
    'HR_segment': 'Human Resources',
    'User Segment': 'User'
}

def extract_segment_flags(text):
    text = str(text).lower()
    return {col: int(keyword.lower() in text) for col, keyword in segment_keywords.items()}

segment_flags_df = df['targeted_segment'].apply(extract_segment_flags).apply(pd.Series)

# === Step 3: Define threat_class keywords and create binary flags === #
threat_keywords = [
    "skip",
    "Abuse of Leaked Data",
    "Space Weather Events",
    "Abuse / Falsification of Rights",
    "Compromising Confidential Information (Data Breaches): Exfiltration",
    "Denial of Service (DoS)",
    "Data Modification",
    "Electromagnetic Interference",
    "Firmware Corruption",
    "Identity Theft",
    "Malicious Code / Software / Activity: Cryptographic Exploit",
    "Malicious Code / Software / Activity: Malicious Injection",
    "Malicious Code / Software / Activity: Network Exploit",
    "Malicious Code / Software / Activity: Software and vulnerabilities exploit",
    "Manipulation of Hardware and Software: Zero-Day Exploit",
    "Preventing Services",
    "Resource Exhaustion",
    "Seizure of Control: Satellite Bus",
    "Social Engineering",
    "Spoofing",
    "Supply Chain Compromise",
    "Theft of Authentication Information",
    "Unauthorised Modifications: Parameters",
    "Jamming",
    "Unauthorised Use of Equipment",
    "Hijacking",
    "Interception of Communication",
    "Man-in-the-middle",
    "Network Manipulation (Bus-Payload Link",
    "Network Traffic Manipulation (TC - Telecommand)",
    "Position Detection (Telemetry)",
    "Replay of Recorded Authentic Communication Traffic",
    "Unauthorised Access",
    "Coercion, Extortion or Corruption",
    "Damage / Destruction of Segment Assets",
    "Damage / Destruction of the Satellite via the Use of ASAT (Anti-Satellite Weapon) / Proximity Operations",
    "Loss During Shipping",
    "Sabotage Through Hardware / Software",
    "Unauthorized Physical Access",
    "Unintentional Damage (UD)",
    "Lack of Segregation",
    "Operating Errors",
    "Software Misconfiguration",
    "Inadequate Security Planning / Management",
    "Cosmic Radiation",
    "Micrometeoroids and Space Dust"
]

# Create regex-safe lowercase versions for matching
threat_patterns = {kw: re.escape(kw.lower()) for kw in threat_keywords}

def extract_threat_flags(text):
    text = str(text).lower()
    return {
        kw: int(bool(re.search(rf'\b{pattern}\b', text)))
        for kw, pattern in threat_patterns.items()
    }

threat_flags_df = df['threat_class'].apply(extract_threat_flags).apply(pd.Series)

# === Step 4: Combine all columns into the final DataFrame === #
df_combined = pd.concat([df, segment_flags_df, threat_flags_df], axis=1)

# === Step 5: (Optional) Save to Excel === #
df_combined.to_excel('/content/Emm_Post_processed.xlsx', index=False)

# === Step 6: Show sample === #
df_combined.head()

import pandas as pd
import re

# === Step 1: Load the Excel file === #
file_path = '/content/2022_gdelt_official.xlsx'
df = pd.read_excel(file_path)

# === Step 2: Define targeted_segment keywords and create binary flags === #
segment_keywords = {
    'Space Segment': 'Space',
    'Ground Segment': 'Ground',
    'HR_segment': 'Human Resources',
    'User Segment': 'User'
}

def extract_segment_flags(text):
    text = str(text).lower()
    return {col: int(keyword.lower() in text) for col, keyword in segment_keywords.items()}

segment_flags_df = df['targeted_segment'].apply(extract_segment_flags).apply(pd.Series)

# === Step 3: Define threat_class keywords and create binary flags === #
threat_keywords = [
    "skip",
    "Abuse of Leaked Data",
    "Space Weather Events",
    "Abuse / Falsification of Rights",
    "Compromising Confidential Information (Data Breaches): Exfiltration",
    "Denial of Service (DoS)",
    "Data Modification",
    "Electromagnetic Interference",
    "Firmware Corruption",
    "Identity Theft",
    "Malicious Code / Software / Activity: Cryptographic Exploit",
    "Malicious Code / Software / Activity: Malicious Injection",
    "Malicious Code / Software / Activity: Network Exploit",
    "Malicious Code / Software / Activity: Software and vulnerabilities exploit",
    "Manipulation of Hardware and Software: Zero-Day Exploit",
    "Preventing Services",
    "Resource Exhaustion",
    "Seizure of Control: Satellite Bus",
    "Social Engineering",
    "Spoofing",
    "Supply Chain Compromise",
    "Theft of Authentication Information",
    "Unauthorised Modifications: Parameters",
    "Jamming",
    "Unauthorised Use of Equipment",
    "Hijacking",
    "Interception of Communication",
    "Man-in-the-middle",
    "Network Manipulation (Bus-Payload Link",
    "Network Traffic Manipulation (TC - Telecommand)",
    "Position Detection (Telemetry)",
    "Replay of Recorded Authentic Communication Traffic",
    "Unauthorised Access",
    "Coercion, Extortion or Corruption",
    "Damage / Destruction of Segment Assets",
    "Damage / Destruction of the Satellite via the Use of ASAT (Anti-Satellite Weapon) / Proximity Operations",
    "Loss During Shipping",
    "Sabotage Through Hardware / Software",
    "Unauthorized Physical Access",
    "Unintentional Damage (UD)",
    "Lack of Segregation",
    "Operating Errors",
    "Software Misconfiguration",
    "Inadequate Security Planning / Management",
    "Cosmic Radiation",
    "Micrometeoroids and Space Dust"
]

# Create regex-safe lowercase versions for matching
threat_patterns = {kw: re.escape(kw.lower()) for kw in threat_keywords}

def extract_threat_flags(text):
    text = str(text).lower()
    return {
        kw: int(bool(re.search(rf'\b{pattern}\b', text)))
        for kw, pattern in threat_patterns.items()
    }

threat_flags_df = df['threat_class'].apply(extract_threat_flags).apply(pd.Series)

# === Step 4: Combine all columns into the final DataFrame === #
df_combined = pd.concat([df, segment_flags_df, threat_flags_df], axis=1)

# === Step 5: (Optional) Save to Excel === #
df_combined.to_excel('/content/GDELT_Post_processed.xlsx', index=False)

# === Step 6: Show sample === #
df_combined.head()

# estraggo country da country code

# Install pycountry first (only needed once per Colab session)
!pip install pycountry openpyxl

import pandas as pd
import pycountry
from google.colab import files

# Load the Excel file
file_path = '/content/GDELT_Post_processed.xlsx'
df = pd.read_excel(file_path)

# Function to convert alpha-3 country codes to harmonized full country names
def get_country_name(code):
    if pd.isna(code):
        return None
    try:
        country = pycountry.countries.get(alpha_3=code.strip().upper())
        return country.name if country else None
    except:
        return None

# Create new columns with standardized country names
df['country1_extended'] = df['actor_1_country_code'].apply(get_country_name)
df['country2_extended'] = df['actor_2_country_code'].apply(get_country_name)

# Save to new Excel file
output_path = '/content/GDELT_Post_processed_with_countries.xlsx'
df.to_excel(output_path, index=False)

# Download the file
files.download(output_path)

# Install required packages
!pip install pycountry openpyxl

import pandas as pd
import pycountry
from google.colab import files

# Load the Excel file
file_path = '/content/GDELT_Post_processed.xlsx'
df = pd.read_excel(file_path)

# Custom dictionary for non-country codes (regions, special areas)
region_mapping = {
    'AFR': 'Africa',
    'EUR': 'Europe',
    'MEA': 'Middle East and Africa',
    'MDE': 'Middle East',
    'LAM': 'Latin America',
    'WAF': 'West Africa',
    'EAF': 'East Africa',
    'SAS': 'South Asia',
    'EAS': 'East Asia',
    'SEA': 'Southeast Asia',
    'NMB': 'Non-Member Countries',
    'WORLD': 'World',
    'GLOB': 'Global',
    'WEU': 'Western Europe',
    'EEU': 'Eastern Europe',
    'CAR': 'Caribbean',
    'CSA': 'Central & South America',
    'NAM': 'North America',
    'APAC': 'Asia Pacific',
    'ASI': 'Asia',
    'BALK': 'Balkans',
    'SCN': 'Scandinavia',
    'UNK': 'Unknown'
}

# Function to convert alpha-3 codes to country/region names
def get_country_or_region_name(code):
    if pd.isna(code):
        return None
    code = code.strip().upper()

    # Try ISO country first
    country = pycountry.countries.get(alpha_3=code)
    if country:
        return country.name

    # Check custom region dictionary
    return region_mapping.get(code, None)

# Apply the function to both actor country columns
df['country1_extended'] = df['actor_1_country_code'].apply(get_country_or_region_name)
df['country2_extended'] = df['actor_2_country_code'].apply(get_country_or_region_name)

# Save to new Excel file
output_path = '/content/GDELT_Post_processed_with_countries.xlsx'
df.to_excel(output_path, index=False)

# Download the file
files.download(output_path)

# out of the 8.8% how many are technical, non-technical, both? I would forgive non-technical

import pandas as pd

# Load Excel file
file_path = '/content/GDELT_Post_processed_with_countries.xlsx'
df = pd.read_excel(file_path)

# Step 1: Filter rows where threat_issue is "Yes" and threat_attack is empty
subset = df[
    (df['threat_issue'].astype(str).str.strip().str.upper() == 'YES') &
    (df['threat_attack'].isna() | df['threat_attack'].astype(str).str.strip().eq(''))
]

# Step 2: Filter those where neither capability nor vulnerability contains "Yes"
capability = subset['capability'].astype(str).str.upper()
vulnerability = subset['vulnerability'].astype(str).str.upper()

no_yes_subset = subset[
    ~capability.str.contains("YES") & ~vulnerability.str.contains("YES")
]

# Step 3: Clean and normalize technicality column
technicality = no_yes_subset['technicality'].astype(str).str.strip().str.lower()

# Step 4: Count exact matches (case-insensitive)
count_technical     = (technicality == 'technical').sum()
count_non_technical = (technicality == 'non-technical').sum()
count_both          = (technicality == 'both').sum()
total               = len(no_yes_subset)

# Step 5: Print results
print("Results for entries with:")
print("- threat_issue = 'Yes'")
print("- threat_attack = empty")
print("- NO 'Yes' in capability or vulnerability")
print(f"Total entries matching above: {total}\n")

print("Technicality breakdown:")
print(f"‚Ä¢ Technical: {count_technical}")
print(f"‚Ä¢ Non-technical: {count_non_technical}")
print(f"‚Ä¢ Both: {count_both}")

#what is the percentage of noisy rows considering threat_issue Yes and then empty threat attack but also no vulnerability, no capability no HT?

import pandas as pd

# Load the dataset
file_path = '/content/GDELT_Post_processed_with_countries.xlsx'
df = pd.read_excel(file_path)

# Total number of rows in the dataset
total_rows = len(df)

# Step 1: Base filter
base_filter = (
    (df['threat_issue'].astype(str).str.strip().str.upper() == 'YES') &
    (df['threat_attack'].isna() | df['threat_attack'].astype(str).str.strip().eq(''))
)

# Step 2: Check capability and vulnerability do NOT contain "YES"
capability = df['capability'].astype(str).str.upper()
vulnerability = df['vulnerability'].astype(str).str.upper()
no_yes_cap_vul = ~capability.str.contains("YES") & ~vulnerability.str.contains("YES")

# Step 3: technicality is NOT "Non-technical"
technicality = df['technicality'].astype(str).str.strip().str.lower()
not_non_technical = (technicality != 'non-technical')

# Step 4: Combine all logic
noisy_filter = base_filter & no_yes_cap_vul & not_non_technical
noisy_rows = df[noisy_filter]
noisy_count = len(noisy_rows)

# Step 5: Calculate percentage
percentage_noisy = (noisy_count / total_rows) * 100

# Step 6: Print results
print(f"Total rows in dataset: {total_rows}")
print(f"Noisy rows: {noisy_count}")
print(f"Percentage of noisy rows: {percentage_noisy:.2f}%")

# now let's check if threat_issue is No and threat_attack is NOT none/empty, I will accept Non-Technical threats (because Technical should only be related to space), but will consider Both/Technical as noisy (how much are they?)
#of course then I should analyze tects and check for the reason (are they NOT space related Infrastructure, but space relying? if yes this would explain technical threats)

import pandas as pd

# Load dataset (adjust path if needed)
file_path = '/content/GDELT_Post_processed_with_countries.xlsx'
df = pd.read_excel(file_path)

total_rows = len(df)

# Step 1: Filter for threat_issue == "No"
threat_issue_no = df['threat_issue'].astype(str).str.strip().str.upper() == 'NO'

# Step 2: threat_attack is NOT empty (non-null and not blank)
threat_attack_not_empty = ~df['threat_attack'].isna() & (df['threat_attack'].astype(str).str.strip() != '')

# Step 3: technicality is "Technical" or "Both"
technicality = df['technicality'].astype(str).str.strip().str.lower()
tech_or_both = technicality.isin(['technical', 'both'])

# Step 4: Combine all filters
noisy_filter_2 = threat_issue_no & threat_attack_not_empty & tech_or_both
noisy_rows_2 = df[noisy_filter_2]
noisy_count_2 = len(noisy_rows_2)

# Step 5: Calculate percentage
percentage_noisy_2 = (noisy_count_2 / total_rows) * 100

# Step 6: Print results
print(f"Total rows in dataset: {total_rows}")
print(f"Noisy rows (threat_issue='No' but threat_attack present + technicality=Technical/Both): {noisy_count_2}")
print(f"Percentage of noisy rows: {percentage_noisy_2:.2f}%")

#su EMM entrambi

import pandas as pd

file_path = '/content/Emm_Post_processed.xlsx'
df = pd.read_excel(file_path)

total_rows = len(df)

# Normalize columns with consistent casing and strip spaces
df['space_related'] = df['space_related'].fillna('').astype(str).str.strip().str.upper()
df['threat_attack'] = df['threat_attack'].fillna('').astype(str).str.strip().str.upper()
df['technicality'] = df['technicality'].fillna('').astype(str).str.strip().str.upper()
df['capability'] = df['capability'].fillna('').astype(str).str.strip().str.upper()
df['vulnerability'] = df['vulnerability'].fillna('').astype(str).str.strip().str.upper()

# First calculation:
# space_related == YES
# threat_attack empty
# technicality NOT in NONE, NON-TECHNICAL, or empty
condition1 = (
    (df['space_related'] == 'YES') &
    (df['threat_attack'] == '') &
    (~df['technicality'].isin(['NONE', 'NON-TECHNICAL', '']))
)

# Second calculation:
# space_related == YES
# threat_attack NOT empty
# technicality empty
# capability and vulnerability do NOT contain YES
condition2 = (
    (df['space_related'] == 'YES') &
    (df['threat_attack'] != '') &
    (df['technicality'] == '') &
    (~df['capability'].str.contains("YES")) &
    (~df['vulnerability'].str.contains("YES"))
)

noisy_1 = df[condition1]
noisy_2 = df[condition2]

count_noisy_1 = len(noisy_1)
count_noisy_2 = len(noisy_2)

percent_noisy_1 = (count_noisy_1 / total_rows) * 100
percent_noisy_2 = (count_noisy_2 / total_rows) * 100

print(f"Total rows in dataset: {total_rows}\n")

print("First calculation noisy rows:")
print(f"Count: {count_noisy_1}")
print(f"Percentage: {percent_noisy_1:.2f}%\n")

print("Second calculation noisy rows:")
print(f"Count: {count_noisy_2}")
print(f"Percentage: {percent_noisy_2:.2f}%")









#mistral small 2.0 24B

# INSTALL LIBRARIES
!pip install openai langdetect pandas openpyxl

import pandas as pd
import time
from openai import OpenAI
from langdetect import detect

# === CONFIG: THREE API CLIENTS ===
API_KEY_1 = "sk-d52d0"
#API_KEY_2 = "skd0"
#API_KEY_3 = "sk5a9"
BASE_URL = "https://openrouter.ai/api/v1"

client1 = OpenAI(api_key=API_KEY_1, base_url=BASE_URL)
#client2 = OpenAI(api_key=API_KEY_2, base_url=BASE_URL)
#client3 = OpenAI(api_key=API_KEY_3, base_url=BASE_URL)

# === LOAD DATA ===
df = pd.read_excel("/content/space_emm_189.xlsx")
df['description'] = df['description'].fillna('')

# === LOAD KNOWLEDGE BASE FILES ===
with open('/content/ground_kb.txt', 'r') as f:
    ground_kb = f.read()

with open('/content/space_kb.txt', 'r') as f:
    space_kb = f.read()

with open('/content/user_kb.txt', 'r') as f:
    user_kb = f.read()

with open('/content/hr_kb.txt', 'r') as f:
    hr_kb = f.read()

with open('/content/Space_Threat_Taxonomy.txt', 'r') as f:
    space_threat_taxonomy = f.read()

# === LOAD HYBRID THREATS FROM EXCEL ===
hybrid_df = pd.read_excel("/content/Hybrid Threats.xlsx")
hybrid_threats_text = "\n".join(hybrid_df['Hybrid Threats'].dropna().astype(str).tolist())

# Add Natural Threats
natural_threats = """
**Natural Threats**:
- Space Weather Events
- Cosmic Radiation
- Micrometeoroids and Space Dust
"""
full_threat_kb = space_threat_taxonomy + "\n" + natural_threats

# === LOAD THREAT TYPE MAPPING ===
threat_mapping_df = pd.read_excel("/content/ThreatType_Mapping.xlsx")

def query_model(prompt, client, model="mistralai/mistral-small-3.1-24b-instruct:free", retries=1):
    for attempt in range(retries + 1):
        try:
            print(f"\nüöÄ Sending prompt (length={len(prompt)} chars) to model: {model} ...")
            response = client.chat.completions.create(
                model=model,
                messages=[
                    {"role": "system", "content": "You are an expert in space cybersecurity and intelligence analysis."},
                    {"role": "user", "content": prompt}
                ],
                stream=False,
                temperature=0.4,
                extra_headers={
                    "HTTP-Referer": "https://your-site.example",
                    "X-Title": "SpaceThreatAnalyzer",
                },
                extra_body={}
            )

            # Safe check to avoid list index out of range
            if not hasattr(response, 'choices') or not response.choices:
                raise ValueError("No choices returned from model.")

            content = response.choices[0].message.content.strip()
            if not content:
                raise ValueError("Empty response from model.")
            return content

        except Exception as e:
            print(f"‚ö†Ô∏è Attempt {attempt + 1} failed: {e}")
            if attempt == retries:
                return f"<<ERROR: {str(e)}>>"
            time.sleep(3)

def get_best_matching_threat(description):
    matches = []
    for _, row in threat_mapping_df.iterrows():
        enisa_class = row['ENISA class']
        list_1_threat = row['List 1 Threat']
        relation = row['Relation']
        explanation = row['Explanation']
        instances = str(row.get('Instances', ''))

        keywords = [enisa_class, list_1_threat] + [i.strip() for i in instances.split(',') if i.strip()]
        if any(term.lower() in description.lower() for term in keywords):
            matches.append((enisa_class, list_1_threat, relation, explanation, instances))
    return matches if matches else None

# === MAIN PROCESSING LOOP ===
raw_responses = []
client = client1 #[client1, client2, client3]

for idx in range(0, len(df)):
    row = df.iloc[idx]
    try:
        text = str(row['description'])
        lang = detect(text)
        matching_threats = get_best_matching_threat(text)

        if matching_threats:
            threat_str = "\n".join([
                f"ENISA Class: {enisa_class}, List 1 Threat: {list_1_threat}, Relation: {relation}, Explanation: {explanation}, Instances: {instances}"
                for enisa_class, list_1_threat, relation, explanation, instances in matching_threats
            ])
            prompt = f"""
You are an expert in space threats. The task is to classify the provided description of a space-related event or threat.
**IMPORTANT**: Only use vocabulary from the knowledge base for technical threats, and terminology from hybrid_df for non-technical ones.
**IMPORTANT**: If the news text is just about suppositions, or you cannot be sure, prefer mapping vulnerabilities and capabilities, instead of categories and classes.
Given the following knowledge base and event description, classify the event by matching it to relevant threats:

Knowledge Base:
{full_threat_kb}

Threat Mapping (Matching Threats):
{threat_str}

Event Description:
{text}

Classification:
"""
        else:
            prompt = f"""
You are an expert in space threats, technical (cyber-kinetic-electromagnetic) and non-technical hybrid threats (economic/legal/cognitive war, etc..). The task is to classify the provided description from news of a space-related events or threats to support the decision-making of defence agencies.
**IMPORTANT**: Only use vocabulary from the knowledge base for technical threats, and terminology from hybrid_df for non-technical ones.
**IMPORTANT**: If the description is just about general suppositions, or you cannot be sure, do not risk inferring and saying the false.
Given the following knowledge base and event description, classify the event by matching it to relevant threats:

Knowledge Base:
{full_threat_kb}

Event Description:
{text}

Classification:
"""

        # Append mitigation instructions
        prompt += f"""
**Key Points:**
- [Summarize key points from the news text that indicate threat relevance and classification]
- Please use only the taxonomy terminology:
- for non-technical threats {hybrid_threats_text}
- for technical threats {full_threat_kb}
- You can be supported in Threat Mapping (Matching Threats) {threat_str if matching_threats else 'N/A'}

**Confidence Evaluation Rules** (for assigning High / Medium / Low):
- **High**: The threat is explicitly confirmed or demonstrated in the text (e.g., direct statements of attacks, screenshots, or operational impact).
- **Medium**: The text implies or strongly suggests the threat but lacks direct confirmation or specific technical details.
- **Low**: The threat is speculative, hypothetical, denied by authoritative sources, or mentioned only as a possibility without supporting evidence.

Always pair confidence with specific **evidence** from the text (quote or paraphrased).

---

**Important notes to mitigate classification confusion when using taxonomy and instances:**

- The taxonomy classes and instances can overlap in terminology or granularity; ensure clear distinction between broad **classes** and specific **instances** when labeling.
- The relations **Direct**, **Indirect**, and **Mentioned** reflect levels of confidence and explicitness in the threat description; consider them carefully in the classification reasoning.
- When multiple instances appear within the same class, avoid ambiguous or overlapping labels by referencing the hierarchy and context.
- Be mindful that natural language in the news may use synonyms or varied terminology; align classifications strictly to the taxonomy vocabulary.
- If uncertainty remains high, prefer mapping to **vulnerabilities and capabilities** rather than forcing a direct class or instance label.
- Clearly separate **technical** and **non-technical (hybrid)** threat vocabularies.
- Always justify your classification with concrete **evidence** and **confidence levels** following the rules above.

---

Format output exactly like this (now including confidence and evidence for each threat class):
<<<RESPONSE_START>>>
1. Are there space-related issues? <Yes/No>
2. Is it a threat, attack, incident, or None? (Consider an incident something that happened by mistake; while an attack a voluntary violent action. A threat is something that can devolp in an attack or incident. But if the threat is too general, skip to vulnerabilties): <...>
3. Are the threats technical, or non-technical, or both?: <...>
4. For non-technical ones, which are the Hybrid Threat Types if present: <...>
5. for technical ones: All threats' **categories** from taxonomy that apply: <...>
6. Consequently for each of the previous, which **classes** **only** using vocabulary from **classes** in taxonomy: <...>
7. Term or technology in the analyzed text that retrieved the classed: <...>
8. Does the text provide enough information to retrieve threat **classes** classification? <Yes enough/Not enough>
9. Targeted Segments: <...>
10. Space-related vulnerability?: <Yes + explaination/No>
11. Space-related capability?: <Yes + explaination/No>
12. Lifecycle Phases Affected: <1, 2, 3, 4, 5, 6, 7,>
13. CIA Triad Affected: <C, I, A>
14. Detected Language: <...>
15. Language tone: <...>
16. Polarized?: <...>
17. Fictional?: <...>
18. Claim presence or illogic? <Claim, Illogic + explaination>
19. Reasoning for threat categories: <...>
20. Reasoning for threat classes: <...>
21. For each threat class, provide:
    - a. Confidence Level (High / Medium / Low) based on the strength of evidence in the text.
    - b. Textual evidence (quote or paraphrased) justifying the classification.
<<<RESPONSE_END>>>

Hybrid Threat Categories (from Hybrid Threats.xlsx):
{hybrid_threats_text}

Knowledge base:
{ground_kb}
{space_kb}
{user_kb}
{hr_kb}
{full_threat_kb}

News text to analyze:
{text}
"""
        print(f"üîç Prompt preview:\n{prompt[:500]}...\n{'-' * 60}")
        client = clients[idx % 3]
        content = query_model(prompt, client, model="mistralai/mistral-small-3.1-24b-instruct:free", retries=1)

        try:
            if "8." in content and "6." in content:
                q8_line = next(line for line in content.splitlines() if line.strip().startswith("8."))
                if "Not enough" in q8_line:
                    content_lines = content.splitlines()
                    for i, line in enumerate(content_lines):
                        if line.strip().startswith("6."):
                            content_lines[i] = "6. Consequently for each of the previous, which **classes** **only** using vocabulary from **classes** in taxonomy: <skip>"
                            break
                    content = "\n".join(content_lines)
        except Exception as e:
            print(f"‚ö†Ô∏è Post-processing failed: {e}")

        full_output = f"<<<RESPONSE_START>>>\nDetected Language: {lang}\n{content}\n<<<RESPONSE_END>>>"
        print(f"\n‚úÖ Row {idx + 1} done:\n{full_output}\n{'=' * 80}")
        raw_responses.append(full_output)
        time.sleep(10)

    except Exception as e:
        print(f"‚ùå Error at row {idx + 1}: {e}")
        raw_responses.append(f"<<<RESPONSE_START>>>\nError: {str(e)}\n<<<RESPONSE_END>>>")

# === SAVE OUTPUT ===
df['raw_resp'] = raw_responses
df.to_csv('mistral_small_3.1_24b_results.csv', index=False)

# === DOWNLOAD (Colab only) ===
from google.colab import files
files.download('mistral_small_3.1_24b_results.csv')

# INSTALL LIBRARIES
!pip install openai langdetect pandas openpyxl

import pandas as pd
import time
from openai import OpenAI
from langdetect import detect

# === CONFIG: THREE API CLIENTS ===
API_KEY_1 = "s2d0"
#API_KEY_2 = "sk52d0"
#API_KEY_3 = "sk9"
BASE_URL = "https://openrouter.ai/api/v1"

client1 = OpenAI(api_key=API_KEY_1, base_url=BASE_URL)
#client2 = OpenAI(api_key=API_KEY_2, base_url=BASE_URL)
#client3 = OpenAI(api_key=API_KEY_3, base_url=BASE_URL)

# === LOAD DATA ===
df = pd.read_excel("/content/space_emm_189.xlsx")
df['description'] = df['description'].fillna('')

# === LOAD KNOWLEDGE BASE FILES ===
with open('/content/ground_kb.txt', 'r') as f:
    ground_kb = f.read()

with open('/content/space_kb.txt', 'r') as f:
    space_kb = f.read()

with open('/content/user_kb.txt', 'r') as f:
    user_kb = f.read()

with open('/content/hr_kb.txt', 'r') as f:
    hr_kb = f.read()

with open('/content/Space_Threat_Taxonomy.txt', 'r') as f:
    space_threat_taxonomy = f.read()

# === LOAD HYBRID THREATS FROM EXCEL ===
hybrid_df = pd.read_excel("/content/Hybrid Threats.xlsx")
hybrid_threats_text = "\n".join(hybrid_df['Hybrid Threats'].dropna().astype(str).tolist())

# Add Natural Threats
natural_threats = """
**Natural Threats**:
- Space Weather Events
- Cosmic Radiation
- Micrometeoroids and Space Dust
"""
full_threat_kb = space_threat_taxonomy + "\n" + natural_threats

# === LOAD THREAT TYPE MAPPING ===
threat_mapping_df = pd.read_excel("/content/ThreatType_Mapping.xlsx")

def query_model(prompt, client, model="mistralai/mistral-small-3.1-24b-instruct:free", retries=1):
    for attempt in range(retries + 1):
        try:
            print(f"\nüöÄ Sending prompt (length={len(prompt)} chars) to model: {model} ...")
            response = client.chat.completions.create(
                model=model,
                messages=[
                    {"role": "system", "content": "You are an expert in space cybersecurity and intelligence analysis."},
                    {"role": "user", "content": prompt}
                ],
                stream=False,
                temperature=0.4,
                extra_headers={
                    "HTTP-Referer": "https://your-site.example",
                    "X-Title": "SpaceThreatAnalyzer",
                },
                extra_body={}
            )

            # Safe check to avoid list index out of range
            if not hasattr(response, 'choices') or not response.choices:
                raise ValueError("No choices returned from model.")

            content = response.choices[0].message.content.strip()
            if not content:
                raise ValueError("Empty response from model.")
            return content

        except Exception as e:
            print(f"‚ö†Ô∏è Attempt {attempt + 1} failed: {e}")
            if attempt == retries:
                return f"<<ERROR: {str(e)}>>"
            time.sleep(3)

def get_best_matching_threat(description):
    matches = []
    for _, row in threat_mapping_df.iterrows():
        enisa_class = row['ENISA class']
        list_1_threat = row['List 1 Threat']
        relation = row['Relation']
        explanation = row['Explanation']
        instances = str(row.get('Instances', ''))

        keywords = [enisa_class, list_1_threat] + [i.strip() for i in instances.split(',') if i.strip()]
        if any(term.lower() in description.lower() for term in keywords):
            matches.append((enisa_class, list_1_threat, relation, explanation, instances))
    return matches if matches else None

# === MAIN PROCESSING LOOP ===
raw_responses = []
client = client1 #[client1, client2, client3]

for idx in range(0, len(df)):
    row = df.iloc[idx]
    try:
        text = str(row['description'])
        lang = detect(text)
        matching_threats = get_best_matching_threat(text)

        if matching_threats:
            threat_str = "\n".join([
                f"ENISA Class: {enisa_class}, List 1 Threat: {list_1_threat}, Relation: {relation}, Explanation: {explanation}, Instances: {instances}"
                for enisa_class, list_1_threat, relation, explanation, instances in matching_threats
            ])
            prompt = f"""
You are an expert in space threats. The task is to classify the provided description of a space-related event or threat.
**IMPORTANT**: Only use vocabulary from the knowledge base for technical threats, and terminology from hybrid_df for non-technical ones.
**IMPORTANT**: If the news text is just about suppositions, or you cannot be sure, prefer mapping vulnerabilities and capabilities, instead of categories and classes.
Given the following knowledge base and event description, classify the event by matching it to relevant threats:

Knowledge Base:
{full_threat_kb}

Threat Mapping (Matching Threats):
{threat_str}

Event Description:
{text}

Classification:
"""
        else:
            prompt = f"""
You are an expert in space threats, technical (cyber-kinetic-electromagnetic) and non-technical hybrid threats (economic/legal/cognitive war, etc..). The task is to classify the provided description from news of a space-related events or threats to support the decision-making of defence agencies.
**IMPORTANT**: Only use vocabulary from the knowledge base for technical threats, and terminology from hybrid_df for non-technical ones.
**IMPORTANT**: If the description is just about general suppositions, or you cannot be sure, do not risk inferring and saying the false.
Given the following knowledge base and event description, classify the event by matching it to relevant threats:

Knowledge Base:
{full_threat_kb}

Event Description:
{text}

Classification:
"""

        # Append mitigation instructions
        prompt += f"""
**Key Points:**
- [Summarize key points from the news text that indicate threat relevance and classification]
- Please use only the taxonomy terminology:
- for non-technical threats {hybrid_threats_text}
- for technical threats {full_threat_kb}
- You can be supported in Threat Mapping (Matching Threats) {threat_str if matching_threats else 'N/A'}

**Confidence Evaluation Rules** (for assigning High / Medium / Low):
- **High**: The threat is explicitly confirmed or demonstrated in the text (e.g., direct statements of attacks, screenshots, or operational impact).
- **Medium**: The text implies or strongly suggests the threat but lacks direct confirmation or specific technical details.
- **Low**: The threat is speculative, hypothetical, denied by authoritative sources, or mentioned only as a possibility without supporting evidence.

Always pair confidence with specific **evidence** from the text (quote or paraphrased).

---

**Important notes to mitigate classification confusion when using taxonomy and instances:**

- The taxonomy classes and instances can overlap in terminology or granularity; ensure clear distinction between broad **classes** and specific **instances** when labeling.
- The relations **Direct**, **Indirect**, and **Mentioned** reflect levels of confidence and explicitness in the threat description; consider them carefully in the classification reasoning.
- When multiple instances appear within the same class, avoid ambiguous or overlapping labels by referencing the hierarchy and context.
- Be mindful that natural language in the news may use synonyms or varied terminology; align classifications strictly to the taxonomy vocabulary.
- If uncertainty remains high, prefer mapping to **vulnerabilities and capabilities** rather than forcing a direct class or instance label.
- Clearly separate **technical** and **non-technical (hybrid)** threat vocabularies.
- Always justify your classification with concrete **evidence** and **confidence levels** following the rules above.

---

Format output exactly like this (now including confidence and evidence for each threat class):
<<<RESPONSE_START>>>
1. Are there space-related issues? <Yes/No>
2. Is it a threat, attack, incident, or None? (Consider an incident something that happened by mistake; while an attack a voluntary violent action. A threat is something that can devolp in an attack or incident. But if the threat is too general, skip to vulnerabilties): <...>
3. Are the threats technical, or non-technical, or both?: <...>
4. For non-technical ones, which are the Hybrid Threat Types if present: <...>
5. for technical ones: All threats' **categories** from taxonomy that apply: <...>
6. Consequently for each of the previous, which **classes** **only** using vocabulary from **classes** in taxonomy: <...>
7. Term or technology in the analyzed text that retrieved the classed: <...>
8. Does the text provide enough information to retrieve threat **classes** classification? <Yes enough/Not enough>
9. Targeted Segments: <...>
10. Space-related vulnerability?: <Yes + explaination/No>
11. Space-related capability?: <Yes + explaination/No>
12. Lifecycle Phases Affected: <1, 2, 3, 4, 5, 6, 7,>
13. CIA Triad Affected: <C, I, A>
14. Detected Language: <...>
15. Language tone: <...>
16. Polarized?: <...>
17. Fictional?: <...>
18. Claim presence or illogic? <Claim, Illogic + explaination>
19. Reasoning for threat categories: <...>
20. Reasoning for threat classes: <...>
21. For each threat class, provide:
    - a. Confidence Level (High / Medium / Low) based on the strength of evidence in the text.
    - b. Textual evidence (quote or paraphrased) justifying the classification.
<<<RESPONSE_END>>>

Hybrid Threat Categories (from Hybrid Threats.xlsx):
{hybrid_threats_text}

Knowledge base:
{ground_kb}
{space_kb}
{user_kb}
{hr_kb}
{full_threat_kb}

News text to analyze:
{text}
"""
        print(f"üîç Prompt preview:\n{prompt[:500]}...\n{'-' * 60}")
        client = client1
        content = query_model(prompt, client, model="mistralai/mistral-small-3.1-24b-instruct:free", retries=1)

        try:
            if "8." in content and "6." in content:
                q8_line = next(line for line in content.splitlines() if line.strip().startswith("8."))
                if "Not enough" in q8_line:
                    content_lines = content.splitlines()
                    for i, line in enumerate(content_lines):
                        if line.strip().startswith("6."):
                            content_lines[i] = "6. Consequently for each of the previous, which **classes** **only** using vocabulary from **classes** in taxonomy: <skip>"
                            break
                    content = "\n".join(content_lines)
        except Exception as e:
            print(f"‚ö†Ô∏è Post-processing failed: {e}")

        full_output = f"<<<RESPONSE_START>>>\nDetected Language: {lang}\n{content}\n<<<RESPONSE_END>>>"
        print(f"\n‚úÖ Row {idx + 1} done:\n{full_output}\n{'=' * 80}")
        raw_responses.append(full_output)
        time.sleep(10)

    except Exception as e:
        print(f"‚ùå Error at row {idx + 1}: {e}")
        raw_responses.append(f"<<<RESPONSE_START>>>\nError: {str(e)}\n<<<RESPONSE_END>>>")

# === SAVE OUTPUT ===
df['raw_resp'] = raw_responses
df.to_csv('mistral_small_3.1_24b_results.csv', index=False)

# === DOWNLOAD (Colab only) ===
from google.colab import files
files.download('mistral_small_3.1_24b_results.csv')

